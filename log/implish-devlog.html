<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>implish devlog</title>
<!-- 2013-09-06 Fri 14:02 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="michal wallace" />
<link rel="stylesheet" type="text/css" href="/etc/style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">implish devlog</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. portig pre in picolisp</a>
<ul>
<li><a href="#sec-1-1">1.1. a rule database with compiled and uncompiled rules</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><a id="a2u33eu098g0" name="a2u33eu098g0"></a><span class="section-number-2">1</span> portig pre in picolisp</h2>
<div class="outline-text-2" id="text-1">

<p>
I haven't produced much since this morning, but I've learned a lot about picolisp.
</p>

<p>
Originally, I was thinking I'd do a straight object oriented port of the matcher and pattern classes, but with pilog available, I think using the inference engine is a more interesting choice.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><a id="76g677v098g0" name="76g677v098g0"></a><span class="section-number-3">1.1</span> a rule database with compiled and uncompiled rules</h3>
<div class="outline-text-3" id="text-1-1">

<p>
I'm thinking I build my grammar by adding rules to the database. Like:
</p>

<div class="org-src-container">

<pre class="src src-picolisp">(be <span style="color: #ffffff; font-weight: bold;">rule</span>
   (repeat node (Block Cond)
      (<span style="color: #00ff00;">"repeat"</span> <span style="color: #ff00ff; font-weight: bold;">^</span>
         (<span style="color: #00ffff;">&gt;</span> Block = block )
         <span style="color: #00ff00;">"until"</span> ! Cond = expr ) ) )
</pre>
</div>

<p>
The first item is just the rule name (repeat).
</p>

<p>
The next line contains the grammar, with markup for both parsing and pretty printing.
</p>

<p>
This would be converted to an ast with my grammar combinators:
</p>

<div class="org-src-container">

<pre class="src src-picolisp">'(node:
    (seq:
       (lit: <span style="color: #00ff00;">"repeat"</span>)
       (sub: block)
       (hide: (lit: <span style="color: #00ff00;">"until"</span>))
       (sub: cond) ))
</pre>
</div>

<p>
In haskell, names are not symbols so there would be a data type and then a function that did something with each constructor for that data type&#x2026;
</p>

<p>
But I think in picolisp, these things should just be plain old symbols, which just happen to also evaluate to functions. I like that. :)
</p>

<p>
Of course there would also be a separate construct created for the pretty printer, which would also just be made up of functions.
</p>

<p>
Yeah. I like this. I need sleep though, so I'll have to do it tomorrow.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
