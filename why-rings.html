<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>why-rings</title>
<!-- 2014-02-08 Sat 07:39 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="michal wallace" />
<link rel="stylesheet" type="text/css" href="/etc/style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">why-rings</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. what's a mirror node?</a></li>
<li><a href="#sec-2">2. what is the purpose of the data structure?</a></li>
<li><a href="#sec-3">3. so you have item nodes, ring "parents", and special clasp type that marks the end of the ring and carries the parent pointer?</a></li>
<li><a href="#sec-4">4. in ordinary computer science theory, you have to choose, a subroutine or a thread..not both</a></li>
<li><a href="#sec-5">5. im asking if the tree levels represent subroutines or parallel threads</a></li>
<li><a href="#sec-6">6. why do you imagine people leaving their job like that?</a></li>
</ul>
</div>
</div>
<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2013-06-12 Wed&gt;</span></span>
</p>

<p>
clarifying questions provided by sirdancealo3. :) 
</p>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> what's a mirror node?</h2>
<div class="outline-text-2" id="text-1">
<p>
you get that there are a bunch of rings, and the rings form a tree, right?
</p>

<p>
so.. not all the nodes in the rings have children.
</p>

<p>
if a node has a child, then that child is a ring.
</p>

<p>
but not all nodes have children.
</p>

<p>
so in a normal tree, the nodes without children are the leaves.
</p>

<p>
each of those leaves is on one of the rings.
</p>

<p>
we want the rim to be a ring of all the leaf nodes, but we can't break the rings that are already there.
</p>

<p>
instead, we create a secondary node corresponding to each leaf, and link <i>those</i>.
</p>

<p>
the name 'mirror' indicates both the 1-1 correspondence to the leaf nodes and also the idea of 'stepping through the looking glass', since going downward from a mirror node takes you back to the hub.
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> what is the purpose of the data structure?</h2>
<div class="outline-text-2" id="text-2">
<p>
see&#x2026; the tree contains a program
each ring is a loop.
each node contains an instruction.
multiple rings represent multiple concurrent tasks.
but if you only have one turist (instruction pointer&#x2026;)
then you need to switch between those concurrent tasks.
</p>

<p>
Since every downward link points to a node on a ring, the downward links can rotate to point to different items.
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> so you have item nodes, ring "parents", and special clasp type that marks the end of the ring and carries the parent pointer?</h2>
<div class="outline-text-2" id="text-3">
<p>
item = instruction&#x2026; 
parent = subroutine call&#x2026; 
clasp = return from routine / go back to top of loop
</p>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> in ordinary computer science theory, you have to choose, a subroutine or a thread..not both</h2>
<div class="outline-text-2" id="text-4">
<p>
subroutines and threads are different things.
</p>

<p>
a thread is basically a virtual instruction pointer / cpu&#x2026; it's a thing that moves around the tree of your source code.
</p>

<p>
a subroutine is the thing through which it moves.
</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> im asking if the tree levels represent subroutines or parallel threads</h2>
<div class="outline-text-2" id="text-5">
<p>
think of it as an org chart in a company.
</p>

<p>
each ring is a department or job
</p>

<p>
so it's like a routine that needs to be populated with workers
</p>

<p>
worker = thread.
</p>

<p>
if the company is fully staffed, then each job is filled by a dedicated worker.
</p>

<p>
if the company is not fully staffed, then some workers must fill multiple jobs. (multi-tasking)
</p>

<p>
but suppose there is a job that many different people can do.
</p>

<p>
i might do step 1, and then get called away.
</p>

<p>
now, i remeber that i'm about to do step 2, but you don't know that.
</p>

<p>
so even though you can do the job, you won't because it's already in progress and you don't know where i left it.
</p>

<p>
but suppose instead of keeping it in my head, the steps were arranged in a ring, and there was a pointer showing which one was next.
</p>

<p>
then i can just leave, and whoever shows up next can just start on step 2.
</p>

<p>
the child pointer serves this purpose.
</p>

<p>
or
</p>

<p>
the child pointer could just point at the clasp, which is the "start"
</p>

<p>
(also the end of course)
</p>

<p>
the clasp is allowed to have an arbitrary child
</p>

<p>
so as you walk the tree, you arrive at this clasp.
</p>

<p>
if the child of the clasp is not itself, then you start a new instance of the thread.
</p>

<p>
if the child of the clasp is one of its siblings, then there is work in progress and you can pick up on that job where the last guy left off.
</p>

<p>
(you close the door behind you by setting the clasp's child back to the clasp itself)
</p>

<p>
here's the thing
</p>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> why do you imagine people leaving their job like that?</h2>
<div class="outline-text-2" id="text-6">
<p>
it's just a metaphor.
</p>

<p>
but one reason is that the company is understaffed
</p>

<p>
and so they have to go do their other job.
</p>

<p>
here's the thing:
</p>

<p>
it doesn't matter whether you pick the next task to be done or start a new task.
</p>

<p>
your choice can be completely random.
</p>

<p>
if you resume the previous task, the door closes behind you and the clasp now links back to itself.
</p>

<p>
so if you flip a coin and decide to walk down to the child node, you wind up back where you started immediately.
</p>

<p>
and are presented with the exact same choice again.
</p>

<p>
so you just keep looping until either your coin tells you to start a new instance or some other worker sets the child pointer to resume a task that they're leaving.
</p>

<p>
now for the kicker&#x2026;
</p>

<p>
this property of being able to randomly choose to go forward or descend the tree&#x2026;
</p>

<p>
this same choice works no matter where you are in the tree.
</p>

<p>
that is why, when you reach the bottom, you are simply teleported back to the hub.
</p>

<p>
well. except first you pass "through the looking glass" (the mirror node)
</p>

<p>
which can randomly teleport you to any workstation (leaf node)
</p>

<p>
now, there may not be anything to do there.
</p>

<p>
wait.
</p>

<p>
it's not randomly teleporting you.
</p>

<p>
you are randomly deciding whether to keep walking around the ring or not.
</p>

<p>
(on the mirror nodes, you have the aditional choice of going back through the mirror)
</p>

<p>
so basically all the working memory is stored in little tokens that are sitting
around these nodes.. tokens = documents, whatever&#x2026; whatever you would need to do
in order to do the job at that workstation.
</p>

<p>
since all the data is stored in the tree, the computers can all be very dumb, and hardly even need any ram at all.
</p>

<p>
they only need to be smart enough to do the work in front of them and follow the instructions at that particular node.
</p>
</div>
</div>
</div>
</body>
</html>
