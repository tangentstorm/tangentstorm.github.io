<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>An Arimaa Library for Haskell.</title>
<!-- 2013-09-03 Tue 23:44 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="michal wallace" />
<link rel="stylesheet" type="text/css" href="/etc/style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">An Arimaa Library for Haskell.</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. MODULE Arimaa</a></li>
<li><a href="#sec-2">2. The Pieces</a></li>
<li><a href="#sec-3">3. The Board</a>
<ul>
<li><a href="#sec-3-1">3.1. squares</a></li>
<li><a href="#sec-3-2">3.2. empty board</a></li>
<li><a href="#sec-3-3">3.3. the Board type</a></li>
<li><a href="#sec-3-4">3.4. traps</a></li>
</ul>
</li>
<li><a href="#sec-4">4. navigating the board</a></li>
<li><a href="#sec-5">5. Step and step parser:</a></li>
<li><a href="#sec-6">6. setting up pieces</a></li>
<li><a href="#sec-7">7. board queries</a></li>
<li><a href="#sec-8">8. Movement rules.</a>
<ul>
<li><a href="#sec-8-1">8.1. summary</a></li>
<li><a href="#sec-8-2">8.2. 1. Pieces move in cardinal directions, except that rabbits cannot move backward.</a>
<ul>
<li><a href="#sec-8-2-1">8.2.1. forward and backward:</a></li>
<li><a href="#sec-8-2-2">8.2.2. valid empty squares</a></li>
<li><a href="#sec-8-2-3">8.2.3. valid single-step moves:</a></li>
</ul>
</li>
<li><a href="#sec-8-3">8.3. 2. Pieces can push or pull weaker enemy pieces provided there are &gt;= 2 steps left.</a></li>
<li><a href="#sec-8-4">8.4. 3. A piece is frozen when adjacent to a stronger enemy, unless it is also adjacent to another friendly piece.</a></li>
<li><a href="#sec-8-5">8.5. 4. A piece is killed when placed on a trap, unless it is also adjacent to a friendly piece.</a></li>
</ul>
</li>
<li><a href="#sec-9">9. the Play State Monad</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> MODULE Arimaa</h2>
<div class="outline-text-2" id="text-1">
<p>
Arimaa is an abstract strategy game for two players.
</p>

<p>
See <a href="http://arimaa.com/arimaa/">http://arimaa.com/arimaa/</a>
</p>

<div class="org-src-container">

<pre class="src src-haskell">{-# LANGUAGE TypeSynonymInstances, OverlappingInstances #-}

import Data.Array
import Data.Char
import qualified Data.Map as Map
import qualified Data.String.Utils as DSU
import Control.Monad.State
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> The Pieces</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-haskell">data Animal = R | C | D | H | M | E 
     deriving (Ord, Eq, Show)
data Color = Gold | Silver deriving (Show, Eq)
type Colored a = (Color, a)
type Piece = Colored Animal

showPiece (Gold, a)   = show a
showPiece (Silver, a) = map toLower $ show a


gold   a = (Gold, a)
silver a = (Silver, a)

g = gold
s = silver
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> The Board</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> squares</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">

<pre class="src src-haskell">files = ['a'..'h']
ranks = [1..8]
type Square = (Char, Int)

showSquare (x, y) = x : show y
</pre>
</div>


<p>
To avoid bounds-checking when we look at neighboring pieces, we can surround the board with a one-cell-thick border. Thus any square next to a piece on the board will either be empty, contain a wall, or contain a piece.
</p>

<p>
As a special case, I'm putting "trap" in here, even though it evaluates to the same thing as Empty.
</p>

<div class="org-src-container">

<pre class="src src-haskell">data Content = Empty | Wall | Trap | A Piece
instance Show Content where
    show c = case c of
               Empty     -&gt; " "
               Trap      -&gt; "x"
               Wall      -&gt; "#"
               A (Gold, piece)   -&gt; show piece
               A (Silver, piece) -&gt; map toLower $ show piece
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> empty board</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Here we build an empty board, with a border around the edge.
</p>

<div class="org-src-container">

<pre class="src src-haskell">type BoardShape =  Array Square Content
data Board = Board BoardShape
emptyBoard :: Board
emptyBoard = Board $ array fullBounds
           $ [ (sq, initSquare sq) | sq &lt;- range fullBounds ]

fullBounds = ((westOf 'a', 0), (eastOf 'h', 9))
coreBounds = (('a', 1), ('h',8))
</pre>
</div>

<p>
This may come in handy for traps later on:
</p>

<div class="org-src-container">

<pre class="src src-haskell">initSquare :: Square -&gt; Content
initSquare sq@(x, y)
  | (x &lt; 'a') = Wall
  | (x &gt; 'h') = Wall
  | (y &lt; 1)   = Wall
  | (y &gt; 8)   = Wall
  | isTrap sq = Trap
  | otherwise = Empty

eastOf file = chr $ (ord file) + 1
westOf file = chr $ (ord file) - 1
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> the Board type</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Here's a handy function to show the board, as per the standard ASCII notation
defined at <a href="http://arimaa.com/arimaa/learn/notation.html">http://arimaa.com/arimaa/learn/notation.html</a>
</p>

<div class="org-src-container">

<pre class="src src-haskell">render :: Board -&gt; String
render (Board br) = DSU.join "\n" $ map row [9,8.. -1]
    where row y | y == 9 || y== 0  = " +-----------------+"
                | y == -1          = "   a b c d e f g h  \n"
                | otherwise        = show y ++ "| " ++ cells y ++ " |"
          cells y = DSU.join " " $ map (\x -&gt; show $ br ! (x, y)) files

instance Show (Board) where 
   show = render
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> traps</h3>
<div class="outline-text-3" id="text-3-4">
<div class="org-src-container">

<pre class="src src-haskell">traps :: [Square]
traps = [('c',3), ('c',6), ('f',3), ('f',6)]

isTrap :: Square -&gt; Bool
isTrap ('c', 3) = True
isTrap ('c', 6) = True
isTrap ('f', 3) = True
isTrap ('f', 6) = True
isTrap others = False
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> navigating the board</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">

<pre class="src src-haskell">data Direction = North | South | East | West
  deriving (Eq)
North @: (x, y) = (x, y + 1)
South @: (x, y) = (x, y - 1)
East  @: (x, y) = (eastOf x, y)
West  @: (x, y) = (westOf x, y)
</pre>
</div>

<p>
test: East @ ('d',3) == ('e', 3)
</p>

<div class="org-src-container">

<pre class="src src-haskell">instance (Show) Direction where
    show North = "n"
    show South = "s"
    show East  = "e"
    show West  = "w"
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell">(&gt;&gt;:) :: Square -&gt; Square -&gt; Direction
(x1, y1) &gt;&gt;: (x2, y2) = diff (ord x1 - ord x2, y1-y2)
   where diff ( 1,  0) = West
         diff (-1,  0) = East
         diff ( 0,  1) = North
         diff ( 0, -1) = South
         diff _        = error "&gt;&gt;: only works for 2 numbers" 

cardinals :: [Direction]
cardinals = [North, East, South, West]

neighborSquares :: Square -&gt; [(Direction, Square)]
neighborSquares sq = [(dir, dir @: sq) | dir &lt;- cardinals ]

rev :: Direction -&gt; Direction
rev North = South
rev East  = West
rev South = North
rev West  = East
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Step and step parser:</h2>
<div class="outline-text-2" id="text-5">
<p>
Again, from the standard notation:
</p>

<div class="org-src-container">

<pre class="src src-haskell">data Step
   = Put Piece Square
   | Kill Piece Square
   | Move Piece Square Direction
   | Resign
   | Takeback
   deriving (Eq)

instance (Show) Step where
    show step = case step of
        Put  p s   -&gt; sh p s
        Kill p s   -&gt; sh p s ++ "x"
        Move p s d -&gt; sh p s ++ show d
        Resign     -&gt; "resign"
        Takeback   -&gt; "takeback"
        where sh p s = showPiece p ++ showSquare s
</pre>
</div>


<p>
Parser is pretty simple:
</p>

<div class="org-src-container">

<pre class="src src-haskell">parseStep :: String -&gt; Step
parseStep s@(p:x:y:end)
  | s == "takeback" = Takeback
  | s == "resign"   = Resign 
  | end == ""       = Put  pp (x, py)
  | end == "x"      = Kill pp (x, py)
  | otherwise       = Move pp (x, py) pd
  where pp = parsePiece p
        py = parseRank y
        pd = parseDirection $ head end


parsePiece :: Char -&gt; Piece
parsePiece ch = case ch of 
  -- gold pieces --
  'E' -&gt; g E
  'M' -&gt; g M
  'H' -&gt; g H
  'D' -&gt; g D
  'C' -&gt; g C
  'R' -&gt; g R
  -- silver pieces --
  'e' -&gt; s E
  'm' -&gt; s M
  'h' -&gt; s H
  'd' -&gt; s D
  'c' -&gt; s C
  'r' -&gt; s R

parseRank :: Char -&gt; Int
parseRank ch = case ch of
  '1' -&gt; 1
  '2' -&gt; 2
  '3' -&gt; 3
  '4' -&gt; 4
  '5' -&gt; 5
  '6' -&gt; 6
  '7' -&gt; 7
  '8' -&gt; 8

parseDirection :: Char -&gt; Direction
parseDirection ch = case ch of
  'n' -&gt; North
  's' -&gt; South
  'e' -&gt; East
  'w' -&gt; West
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> setting up pieces</h2>
<div class="outline-text-2" id="text-6">
<p>
So, now I want to actually apply the moves to the board.
</p>

<p>
I couldn't figure out how to convince the type system to let me make Board an instance of Functor, but that's probably okay, because as I visit the squares I actually need to know both the coordinates and the contents. So:
</p>

<div class="org-src-container">

<pre class="src src-haskell">apply :: (Board -&gt; Square -&gt; Content) -&gt; Board -&gt; Board
apply f br = Board $ array fullBounds $ contents
             where contents = [(sq, f br sq) | sq &lt;- range fullBounds]
</pre>
</div>


<p>
Let's see how to define the popular 99of9 opening for gold. (see <a href="http://arimaa.com/arimaa/mwiki/index.php/Setup_Positions">http://arimaa.com/arimaa/mwiki/index.php/Setup_Positions</a> )
</p>

<div class="org-src-container">

<pre class="src src-haskell">steps :: String -&gt; [Step]
steps s = map parseStep $ DSU.split " " s

open99of9 = steps "Ra1 Rb1 Rc1 Cd1 Ce1 Rf1 Rg1 Rh1 Ra2 Hb2 Dc2 Md2 Ee2 Df2 Hg2 Rh2"
</pre>
</div>

<p>
So now:
</p>

<div class="org-src-container">

<pre class="src src-haskell">(//=) :: Board -&gt; [(Square, Content)] -&gt; Board
(Board br) //= changes = Board $ br // changes

step :: Step -&gt; Board -&gt; Board
step st br = case st of
    Put  p sq     -&gt; br //= [(sq, A p)]    
    Kill p sq     -&gt; todo
    Move p sq d   -&gt; todo
    Resign        -&gt; todo
    Takeback      -&gt; todo
  where
    todo = br

doSteps :: [Step] -&gt; Board -&gt; Board
doSteps []      br = br
doSteps (s :ss) br = doSteps ss $ step s br
</pre>
</div>

<p>
How about the same for silver?
</p>

<div class="org-src-container">

<pre class="src src-haskell">mirror :: Step -&gt; Step
mirror (Put (Gold, p) (x, y)) = Put (Silver, p) (x, 9-y)
mirror other = other

board99of9 = doSteps (gold ++ silver) emptyBoard
     where gold   = open99of9
           silver = map mirror gold
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> board queries</h2>
<div class="outline-text-2" id="text-7">
<div class="org-src-container">

<pre class="src src-haskell">type PieceAt = (Piece, Square)
</pre>
</div>

<p>
contents br = [(sq, content br sq) | sq &lt;- range coreBounds]
</p>

<div class="org-src-container">

<pre class="src src-haskell">content sq (Board br) = br ! sq
</pre>
</div>


<div class="org-src-container">

<pre class="src src-haskell">neighbors :: Square -&gt; Board -&gt; [(Direction, PieceAt)]
neighbors square br = [(dir, (pieceAt sq br, sq))
                         | (dir, sq)  &lt;- neighborSquares square
                         , isPiece $ content sq br]
</pre>
</div>


<p>
Enemitos = lesser enemies (spanglish ftw!)
</p>

<div class="org-src-container">

<pre class="src src-haskell">enemitos :: PieceAt -&gt; Board -&gt; [(Direction, PieceAt)]
enemitos ((c, a), sq) br = [n | n@(dir, ((c2, a2), _)) &lt;- neighbors sq br 
                              , a2 &lt; a  &amp;&amp; c2 == opp c]

isPiece :: Content -&gt; Bool
isPiece (A _) = True
isPiece _     = False

toPiece :: Content -&gt; Piece
toPiece (A p) = p
toPiece _     = error "not a piece!"

pieceAt :: Square -&gt; Board -&gt; Piece
pieceAt sq br  = toPiece $ content sq br

pieceSquares br = [sq | sq &lt;- range coreBounds,  isPiece $ content sq br]

isEmpty sq br = case content sq br of
                   Empty -&gt; True
                   Trap  -&gt; True
                   _     -&gt; False

army :: Color -&gt; Board -&gt; [PieceAt]
army c br =  [(pieceAt sq br, sq) | sq &lt;- pieceSquares br
                                  , colorOf (pieceAt sq br) == c]

colorOf :: (Color, a) -&gt; Color
colorOf = fst


isColor :: Color -&gt; (Color, a) -&gt; Bool
isColor c = \x -&gt; colorOf x == c
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Movement rules.</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> summary</h3>
<div class="outline-text-3" id="text-8-1">
<div class="org-src-container">

<pre class="src src-haskell">validSteps :: Board -&gt; Color -&gt; [Step] -&gt; [Step]
validSteps b c ss = [] -- TODO
</pre>
</div>

<p>
validPushes <del>+ validPulls +</del> validSteps
</p>

<div class="org-src-container">

<pre class="src src-haskell">emcTestBoard = doSteps (steps "Ed3 me3 Ce4") emptyBoard
emcE = head $ army Gold emcTestBoard
emcM = head $ army Silver emcTestBoard 
emcC = head $ tail $ army Gold emcTestBoard
</pre>
</div>

<p>
Which looks like this:
</p>

<pre class="example">
 +-----------------+
8|                 |
7|                 |
6|     x     x     |
5|                 |
4|         C       |
3|     x E m x     |
2|                 |
1|                 |
 +-----------------+
   a b c d e f g h
</pre>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> 1. Pieces move in cardinal directions, except that rabbits cannot move backward.</h3>
<div class="outline-text-3" id="text-8-2">
</div><div id="outline-container-sec-8-2-1" class="outline-4">
<h4 id="sec-8-2-1"><span class="section-number-4">8.2.1</span> forward and backward:</h4>
<div class="outline-text-4" id="text-8-2-1">
<div class="org-src-container">

<pre class="src src-haskell">fore :: Color -&gt; Direction
fore Gold   = North
fore Silver = South

back :: Color -&gt; Direction
back = fore . opp

opp Gold = Silver
opp Silver = Gold
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-2-2" class="outline-4">
<h4 id="sec-8-2-2"><span class="section-number-4">8.2.2</span> valid empty squares</h4>
<div class="outline-text-4" id="text-8-2-2">
<div class="org-src-container">

<pre class="src src-haskell">emptyDirs :: PieceAt -&gt; Board -&gt; [Direction]
emptyDirs (p, sq) br = [dir | dir &lt;- potentialDirs p, isEmpty (dir @: sq) br]
</pre>
</div>

<p>
test: [North, East, West] <code>= emptyDirs (('b', 5), (g R)) emptyBoard
test: [South, East, West] =</code> emptyDirs (('b', 5), (s R)) emptyBoard
test: [South, East]       == emptyDirs (('a', 5), (s R)) emptyBoard
</p>

<div class="org-src-container">

<pre class="src src-haskell">potentialDirs :: Piece -&gt; [Direction]
potentialDirs (color, pc) =
   case pc of 
      R  -&gt; (foreAndSides color) 
      _  -&gt; (back color) : (foreAndSides color)
   where foreAndSides color = fore color : [East, West]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-2-3" class="outline-4">
<h4 id="sec-8-2-3"><span class="section-number-4">8.2.3</span> valid single-step moves:</h4>
<div class="outline-text-4" id="text-8-2-3">
<div class="org-src-container">

<pre class="src src-haskell">validMoves :: PieceAt -&gt; Board -&gt; [[Step]]
validMoves pcAt@(p, sq) br = [[Move p sq d] | d &lt;- emptyDirs pcAt br ]
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> 2. Pieces can push or pull weaker enemy pieces provided there are &gt;= 2 steps left.</h3>
<div class="outline-text-3" id="text-8-3">
<div class="org-src-container">

<pre class="src src-haskell">-- &gt;&gt;&gt; validPushes emcE emcTestBoard
-- [[me3s,Ed3e],[me3e,Ed3e]]
-- &gt;&gt;&gt; validPulls emcE emcTestBoard
-- [[Ed3s,me3w],[Ed3n,me3w],[Ed3w,me3w]]
</pre>
</div>

<p>
To push, move the enemy piece, then move your piece where the enemy started.
</p>

<div class="org-src-container">

<pre class="src src-haskell">push :: PieceAt -&gt; Direction -&gt; Direction -&gt; Board -&gt; [Step]
push (pc, sq) pcDir enDir br = [Move en enSq enDir, Move pc sq pcDir]
   where en = pieceAt enSq br
         enSq = pcDir @: sq
</pre>
</div>

<p>
piece p1 can push adjacent enemy p2 if p1 &gt; p2 and p2 has adjacent empty square
</p>

<div class="org-src-container">

<pre class="src src-haskell">validPushes :: PieceAt -&gt; Board -&gt; [[Step]]
validPushes pcAt@((c, a), sq) br = 
   [push pcAt pcDir enDir br
       | (pcDir, en) &lt;- enemitos pcAt br
       , enDir &lt;- emptyDirs en br ]
</pre>
</div>


<p>
To pull, move your piece, then move the enemy to where your piece started.
</p>

<div class="org-src-container">

<pre class="src src-haskell">pull :: PieceAt -&gt; Direction -&gt; Direction -&gt; Board -&gt; [Step]
pull (pc, sq) pcDir enDir br = [Move pc sq pcDir, Move en enSq enDelta]
   where en = pieceAt enSq br
         enSq = enDir @: sq
         enDelta = rev enDir
</pre>
</div>

<p>
piece p1 can pull adjacent enemy p2 if p1 &gt; p2 and p1 has adjacent empty square
</p>

<div class="org-src-container">

<pre class="src src-haskell">validPulls :: PieceAt -&gt; Board -&gt; [[Step]]
validPulls pcAt@((c, a), sq) br = 
   [pull pcAt pcDir enDir br
       | (enDir, en) &lt;- enemitos pcAt br
       , pcDir &lt;- emptyDirs pcAt br ]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> 3. A piece is frozen when adjacent to a stronger enemy, unless it is also adjacent to another friendly piece.</h3>
<div class="outline-text-3" id="text-8-4">
<div class="org-src-container">

<pre class="src src-haskell">-- | is the piece frozen?
-- &gt;&gt;&gt; frozen emcE emcTestBoard
-- False
-- &gt;&gt;&gt; frozen emcM emcTestBoard
-- True
-- &gt;&gt;&gt;  frozen emcC emcTestBoard
-- False
frozen pcAt br | hasFriend pcAt br = False
               | otherwise = hasThreat pcAt br
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell">hasFriend :: PieceAt -&gt; Board -&gt; Bool
hasFriend ((c, _), sq) br = any (\(p, s) -&gt; isColor c p) $ map snd $ neighbors sq br

hasThreat :: PieceAt -&gt; Board -&gt; Bool
hasThreat ((c, a), sq) br = any biggerEnemy $ map snd $ neighbors sq br
   where biggerEnemy ((c2,  a2), _) = (a2 &gt; a) &amp;&amp; (not $ c2 == c)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5"><span class="section-number-3">8.5</span> 4. A piece is killed when placed on a trap, unless it is also adjacent to a friendly piece.</h3>
<div class="outline-text-3" id="text-8-5">
<div class="org-src-container">

<pre class="src src-haskell">trapped :: PieceAt -&gt; Board -&gt; Bool
trapped (p, sq) br = isTrap sq &amp;&amp; (not $ hasFriend (p, sq) br)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> the Play State Monad</h2>
<div class="outline-text-2" id="text-9">
<div class="org-src-container">

<pre class="src src-haskell">type Move = (Color, [Step])
data PlayState = PlayState {
  board     :: Board,
  moveNum   :: Int,
  toMove    :: Color,
  stepsLeft :: Int,
  history   :: [Move],
  future    :: [Move]
} deriving Show

initState = PlayState {
  board     = emptyBoard,
  moveNum   = 1,
  toMove    = Gold,
  stepsLeft = 4,
  history   = [],
  future    = []
}
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
