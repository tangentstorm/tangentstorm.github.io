<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>wejal bootstrap</title>
<!-- 2015-01-22 Thu 08:17 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="michal wallace" />
<link rel="stylesheet" type="text/css" href="/etc/style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">wejal bootstrap</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Strategy</a></li>
<li><a href="#sec-2">2. Some data types for modeling grammar definitions.</a></li>
<li><a href="#sec-3">3. Manually build a base grammar to provide generic tokenization.</a></li>
<li><a href="#sec-4">4. Now define the bootstrap grammar to parse EBNF grammar definitions.</a></li>
<li><a href="#sec-5">5. Generic dispatch:</a></li>
<li><a href="#sec-6">6. Worlds for backtracking.</a></li>
<li><a href="#sec-7">7. Grammar Interpreter</a></li>
<li><a href="#sec-8">8. ebnf in ebnf</a></li>
<li><a href="#sec-9">9. OUTPUT wejalboot.py</a></li>
<li><a href="#sec-10">10. <span class="todo TODO">TODO</span> Input cursor</a></li>
<li><a href="#sec-11">11. Data structure for parse results.</a></li>
<li><a href="#sec-12">12. Inference Rules</a></li>
<li><a href="#sec-13">13. Compilation step.</a></li>
<li><a href="#sec-14">14. <span class="todo TODO">TODO</span> credits</a></li>
</ul>
</div>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><a id="nrogjy71jqg0" name="nrogjy71jqg0"></a><span class="section-number-2">1</span> Strategy</h2>
<div class="outline-text-2" id="text-1">

<p>
The idea here is to manually construct a data structure (an abstract syntax tree) that describes a meta-grammar.
</p>

<p>
The meta-grammar describes whatever nice clean syntax we'd <i>like</i> to use for creating grammars in the future.
</p>

<p>
Building these trees by hand can get messy, though, so we'll stick with a simple syntax for this first round, and then use <i>that</i> to implement something better later.
</p>

<p>
Our first step is to define some types that we can use to tag the different parts of the tree. Each type represents the some feature of our pattern matching system.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><a id="9906u111jqg0" name="9906u111jqg0"></a><span class="section-number-2">2</span> Some data types for modeling grammar definitions.</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-python" id="imports"><span style="color: #00ffff;">from</span> collections <span style="color: #00ffff;">import</span> namedtuple
</pre>
</div>
<div class="org-src-container">

<pre class="src src-python" id="code"><span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">T</span>(tag, doc=<span style="color: #00ff00;">''</span>, args)
    <span style="color: #00ff00;">"""Creates a new tuple type."""</span>
    <span style="color: #eedd82;">res</span> = namedtuple(tag, args)
    <span style="color: #00ffff;">if</span> doc: res.<span style="color: #ff00ff; font-weight: bold;">__doc__</span>+=<span style="color: #00ff00;">' : '</span>+doc
    <span style="color: #00ffff;">return</span> res

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">TB</span>(tag, doc, args=[<span style="color: #00ff00;">'body'</span>]): <span style="color: #00ffff;">return</span> T(tag, doc, args)
<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">TI</span>(tag, doc, args=[<span style="color: #00ff00;">'item'</span>]): <span style="color: #00ffff;">return</span> T(tag, doc, args)
<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">TN</span>(tag, doc, args=[<span style="color: #00ff00;">'name'</span>]): <span style="color: #00ffff;">return</span> T(tag, doc, args)
<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">T2</span>(tag, doc, args=[<span style="color: #00ff00;">'name'</span>,<span style="color: #00ff00;">'body'</span>]): <span style="color: #00ffff;">return</span> T(tag, doc, args)

<span style="color: #eedd82;">Gram</span> = T(<span style="color: #00ff00;">'Gram'</span>, <span style="color: #00ff00;">'contains grammar rules (may inherit from `base`).'</span>,
         [<span style="color: #00ff00;">'name'</span>, <span style="color: #00ff00;">'base'</span>, <span style="color: #00ff00;">'doc'</span>, <span style="color: #00ff00;">'body'</span>])
<span style="color: #eedd82;">Def</span> = T(<span style="color: #00ff00;">'Def'</span>, <span style="color: #00ff00;">'define a named rule.'</span>, [<span style="color: #00ff00;">'name'</span>,<span style="color: #00ff00;">'body'</span>])
<span style="color: #eedd82;">Ref</span> = TN(<span style="color: #00ff00;">'Ref'</span>, <span style="color: #00ff00;">'refer to (invoke) a named rule'</span>)

<span style="color: #eedd82;">Any</span> = T(<span style="color: #00ff00;">'Any'</span>, <span style="color: #00ff00;">'match anything'</span>, [])
<span style="color: #eedd82;">Not</span> = TI(<span style="color: #00ff00;">'Not'</span>, <span style="color: #00ff00;">'fail if the pattern would match, but do not consume'</span>)
<span style="color: #eedd82;">Skip</span> = TI(<span style="color: #00ff00;">'Skip'</span>, <span style="color: #00ff00;">'match the pattern, but hide it from other rules'</span>)

<span style="color: #eedd82;">Lit</span> = TI(<span style="color: #00ff00;">'Lit'</span>, <span style="color: #00ff00;">'match literal item (using ==)'</span>)
<span style="color: #eedd82;">Seq</span> = TB(<span style="color: #00ff00;">'Seq'</span>, <span style="color: #00ff00;">'match a sequence of patterns'</span>)
<span style="color: #eedd82;">Grp</span> = TB(<span style="color: #00ff00;">'Grp'</span>, <span style="color: #00ff00;">'same as Seq, but renders in parentheses'</span>)
<span style="color: #eedd82;">Alt</span> = TB(<span style="color: #00ff00;">'Alt'</span>, <span style="color: #00ff00;">'match any of the alternatives'</span>)
<span style="color: #eedd82;">Rep</span> = TI(<span style="color: #00ff00;">'Rep'</span>, <span style="color: #00ff00;">'match 1 or more repetitions.'</span>)
<span style="color: #eedd82;">Opt</span> = TI(<span style="color: #00ff00;">'Opt'</span>, <span style="color: #00ff00;">'match 0 or 1 repetitions.'</span>)
<span style="color: #eedd82;">Orp</span> = TI(<span style="color: #00ff00;">'Orp'</span>, <span style="color: #00ff00;">'match 0 or more repetitions.'</span>)

<span style="color: #eedd82;">Var</span> = T2(<span style="color: #00ff00;">'Var'</span>, <span style="color: #00ff00;">'save matched string in a variable.'</span>)
<span style="color: #eedd82;">Val</span> = TN(<span style="color: #00ff00;">'Val'</span>, <span style="color: #00ff00;">'match against the saved value.'</span>)
<span style="color: #eedd82;">New</span> = T2(<span style="color: #00ff00;">'New'</span>, <span style="color: #00ff00;">'build a new class/tuple instance'</span>)
<span style="color: #eedd82;">Arg</span> = TB(<span style="color: #00ff00;">'Arg'</span>, <span style="color: #00ff00;">'pass matched data as arg to containing "New"'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><a id="9d0f2971jqg0" name="9d0f2971jqg0"></a><span class="section-number-2">3</span> Manually build a base grammar to provide generic tokenization.</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-python" id="imports"><span style="color: #00ffff;">import</span> string
</pre>
</div>
<div class="org-src-container">

<pre class="src src-python" id="code"><span style="color: #eedd82;">ECHR</span>, <span style="color: #eedd82;">SQ</span>, <span style="color: #eedd82;">DQ</span> = [<span style="color: #00ff00;">'\\'</span>, <span style="color: #00ff00;">"'"</span>, <span style="color: #00ff00;">'"'</span>]
<span style="color: #eedd82;">base</span> = Gram(<span style="color: #00ff00;">'ebnf'</span>, [], <span style="color: #00ff00;">"rules common to all grammars"</span>, [
    Def(<span style="color: #00ff00;">'main'</span>, Orp(<span style="color: #00ff00;">'token'</span>)),
    Def(<span style="color: #00ff00;">'token'</span>,Seq([Skip(Orp(Ref(<span style="color: #00ff00;">'space'</span>))),
                  Alt([Ref(<span style="color: #00ff00;">'STRING'</span>), Ref(<span style="color: #00ff00;">'NUMBER'</span>),
                       Ref(<span style="color: #00ff00;">'IDENT'</span>), Ref(<span style="color: #00ff00;">'DELIM'</span>),
                       Rep(Not(Ref(<span style="color: #00ff00;">'space'</span>)))])])),
    Def(<span style="color: #00ff00;">'space'</span>, Orp(<span style="color: #00ff00;">'White'</span>)),
    <span style="color: #66f;"># </span><span style="color: #66f;">character classes:</span>
    Def(<span style="color: #00ff00;">'White'</span>, Alt([<span style="color: #ff00ff; font-weight: bold;">chr</span>(c) <span style="color: #00ffff;">for</span> c <span style="color: #00ffff;">in</span> <span style="color: #ff00ff; font-weight: bold;">range</span>(33)])),
    Def(<span style="color: #00ff00;">'Upper'</span>, Alt(<span style="color: #ff00ff; font-weight: bold;">list</span>(string.ascii_uppercase))),
    Def(<span style="color: #00ff00;">'Lower'</span>, Alt(<span style="color: #ff00ff; font-weight: bold;">list</span>(string.ascii_lowercase))),
    Def(<span style="color: #00ff00;">'Alpha'</span>, Alt([Ref(<span style="color: #00ff00;">'Lower'</span>), Ref(<span style="color: #00ff00;">'Upper'</span>)])),
    Def(<span style="color: #00ff00;">'Under'</span>, Lit(<span style="color: #00ff00;">'_'</span>)),
    Def(<span style="color: #00ff00;">'Neg'</span>, Lit(<span style="color: #00ff00;">'-'</span>)),
    Def(<span style="color: #00ff00;">'Digit'</span>, Alt([Lit(c) <span style="color: #00ffff;">for</span> c <span style="color: #00ffff;">in</span> string.digits])),
    Def(<span style="color: #00ff00;">'Hexit'</span>, Alt([Ref(<span style="color: #00ff00;">'Digit'</span>)]+[Lit(c) <span style="color: #00ffff;">for</span> c <span style="color: #00ffff;">in</span> <span style="color: #00ff00;">'abcdefABCDEF'</span>])),
    Def(<span style="color: #00ff00;">'Alnum'</span>, Alt([Ref(<span style="color: #00ff00;">'Under'</span>), Ref(<span style="color: #00ff00;">'Alpha'</span>), Ref(<span style="color: #00ff00;">'Digit'</span>)])),
    <span style="color: #66f;"># </span><span style="color: #66f;">simple patterns:</span>
    Def(<span style="color: #00ff00;">'IDENT'</span>, Seq([Alt([Ref(<span style="color: #00ff00;">'Under'</span>),Ref(<span style="color: #00ff00;">'Alpha'</span>)]), Orp(Ref(<span style="color: #00ff00;">'Alnum'</span>))])),
    Def(<span style="color: #00ff00;">'NUMBER'</span>,Seq([Opt(Ref(<span style="color: #00ff00;">'Neg'</span>)), Rep(Ref(<span style="color: #00ff00;">'Digit'</span>)),
                   Orp([Ref(<span style="color: #00ff00;">'Under'</span>),
                        Ref(<span style="color: #00ff00;">'Digit'</span>),Ref(<span style="color: #00ff00;">'Digit'</span>),Ref(<span style="color: #00ff00;">'Digit'</span>)])])),
    Def(<span style="color: #00ff00;">'STRING'</span>, Alt([Seq([Lit(DQ), Rep(Ref(<span style="color: #00ff00;">'STRCHR'</span>)), Lit(DQ)])])),
    Def(<span style="color: #00ff00;">'STRCHR'</span>, Alt([Seq([Lit(ECHR), Alt([ Lit(ECHR), Lit(DQ) ])]),
                       Not(DQ) ])),
    Def(<span style="color: #00ff00;">'DELIM'</span>, Alt(<span style="color: #ff00ff; font-weight: bold;">list</span>(<span style="color: #00ff00;">'(){}[]'</span>))),
])
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><a id="7o9j7i21jqg0" name="7o9j7i21jqg0"></a><span class="section-number-2">4</span> Now define the bootstrap grammar to parse EBNF grammar definitions.</h2>
<div class="outline-text-2" id="text-4">

<div class="org-src-container">

<pre class="src src-python" id="code"><span style="color: #eedd82;">ebnf</span> = Gram(<span style="color: #00ff00;">'ebnf'</span>, [base], <span style="color: #00ff00;">"ebnf meta-grammar (for parsing grammars)"</span>, [
    Def(<span style="color: #00ff00;">'main'</span>, Orp(Ref(<span style="color: #00ff00;">'rule'</span>))),
    Def(<span style="color: #00ff00;">'rule'</span>, Seq([Var(<span style="color: #00ff00;">'name'</span>, Ref(<span style="color: #00ff00;">'IDENT'</span>)),
                     Lit(<span style="color: #00ff00;">'='</span>), Ref(<span style="color: #00ff00;">'expr'</span>), Lit(<span style="color: #00ff00;">'.'</span>) ])),
    Def(<span style="color: #00ff00;">'expr'</span>, Seq([ Ref(<span style="color: #00ff00;">'term'</span>), Orp([Lit(<span style="color: #00ff00;">'|'</span>), Ref(<span style="color: #00ff00;">'term'</span>) ]) ])),
    Def(<span style="color: #00ff00;">'term'</span>, Seq([ Ref(<span style="color: #00ff00;">'factor'</span>), Rep(Ref(<span style="color: #00ff00;">'factor'</span>)) ])),
    Def(<span style="color: #00ff00;">'factor'</span>, Alt([Ref(<span style="color: #00ff00;">'IDENT'</span>), Ref(<span style="color: #00ff00;">'STRING'</span>),
                       Ref(<span style="color: #00ff00;">'rep'</span>), Ref(<span style="color: #00ff00;">'opt'</span>), Ref(<span style="color: #00ff00;">'grp'</span>)])),
    Def(<span style="color: #00ff00;">'rep'</span>, Seq([Lit(<span style="color: #00ff00;">'{'</span>), New(Rep, Ref(<span style="color: #00ff00;">'expr'</span>)), Lit(<span style="color: #00ff00;">'}'</span>)])),  <span style="color: #66f;"># </span><span style="color: #66f;">'x*'</span>
    Def(<span style="color: #00ff00;">'opt'</span>, Seq([Lit(<span style="color: #00ff00;">'['</span>), New(Opt, Ref(<span style="color: #00ff00;">'expr'</span>)), Lit(<span style="color: #00ff00;">']'</span>)])),  <span style="color: #66f;"># </span><span style="color: #66f;">'x?'</span>
    Def(<span style="color: #00ff00;">'grp'</span>, Seq([Lit(<span style="color: #00ff00;">'('</span>), New(Grp, Ref(<span style="color: #00ff00;">'expr'</span>)), Lit(<span style="color: #00ff00;">')'</span>)])),  <span style="color: #66f;"># </span><span style="color: #66f;">'(x)'</span>
])
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><a id="w0bhd8b1jqg0" name="w0bhd8b1jqg0"></a><span class="section-number-2">5</span> Generic dispatch:</h2>
<div class="outline-text-2" id="text-5">
<p>
We need a way walk these trees and dispatch to an appropriate method for each type of node in our AST.
</p>

<div class="org-src-container">

<pre class="src src-python" id="imports"><span style="color: #00ffff;">from</span> warnings <span style="color: #00ffff;">import</span> warn
</pre>
</div>

<div class="org-src-container">

<pre class="src src-python" id="code"><span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Dispatcher</span>(<span style="color: #ff00ff; font-weight: bold;">object</span>):
    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__init__</span>(<span style="color: #00ffff;">self</span>, tree):
        <span style="color: #00ffff;">self</span>.root = tree
        <span style="color: #00ffff;">self</span>.done = <span style="color: #ffaf00;">False</span>
        <span style="color: #00ffff;">self</span>.node = <span style="color: #ffaf00;">None</span>
        <span style="color: #00ffff;">self</span>.path = [] <span style="color: #66f;"># </span><span style="color: #66f;">stack of breadcrumbs from the root</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">unhandled</span>(<span style="color: #00ffff;">self</span>, node):
        <span style="color: #00ffff;">yield</span> warn(<span style="color: #00ff00;">'no handler for tag: %s'</span> % node.__class__.<span style="color: #ff00ff; font-weight: bold;">__name__</span>)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">walk</span>(<span style="color: #00ffff;">self</span>, node):
        <span style="color: #eedd82;">tag</span> = node.__class__.<span style="color: #ff00ff; font-weight: bold;">__name__</span>
        <span style="color: #eedd82;">meth</span> = <span style="color: #ff00ff; font-weight: bold;">getattr</span>(<span style="color: #00ffff;">self</span>, <span style="color: #00ff00;">'on'</span>+tag, <span style="color: #00ffff;">self</span>.unhandled)
        <span style="color: #00ffff;">self</span>.path.append(<span style="color: #00ffff;">self</span>.node); <span style="color: #00ffff;">self</span>.node = node
        <span style="color: #00ffff;">yield</span> <span style="color: #00ffff;">from</span> meth(node)
        <span style="color: #00ffff;">self</span>.node = <span style="color: #00ffff;">self</span>.path.pop()
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><a id="u8s6vh00kqg0" name="u8s6vh00kqg0"></a><span class="section-number-2">6</span> Worlds for backtracking.</h2>
<div class="outline-text-2" id="text-6">

<p>
A world is a context for holding changes, similar to a working copy in a version control system. The idea is that any time we might need to backtrack (any time an <code>Alt</code> node is encountered), we'll fork a new world, and changes we make are done to the world object. This way, if the match ultimately fails, we can rewind the side effects.
</p>

<p>
This ability is common in prototype-based langugaes like Self and JavaScript (though it isn't necessarily commonly <i>used</i>). The name 'World' and the idea of applying it to parsing comes from Alex Warth's <a href="http://www.tinlizzie.org/ometa/">OMeta</a> dissertation.
</p>

<p>
It's easy to make a python class that works this way: we just override <code>__getattr__</code> (for the <code>x.a</code> syntax), and <code>__getitem__</code> (for the <code>x[a]</code> syntax) so that they delegate to a prototype object when there's no local value defined.
</p>

<p>
Since we do <i>not</i> override the corresponding <code>__setitem__</code> and <code>__setattr__</code> methods, any assignment made to an attribute or item of the world will affect the local object, leaving the prototype's value unchanged.
</p>

<p>
It's very much like what happens when overriding methods in a subclass, except it happens for individual objects rather than classes, and it happens dynamically at runtime.
</p>

<div class="org-src-container">

<pre class="src src-python" id="code"><span style="color: #eedd82;">HOME</span> = {} <span style="color: #66f;"># </span><span style="color: #66f;">arbitrary dictionary object</span>

<span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">World</span>(<span style="color: #ff00ff; font-weight: bold;">dict</span>):

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__init__</span>(<span style="color: #00ffff;">self</span>, proto=HOME):
        <span style="color: #ff00ff; font-weight: bold;">super</span>(World, <span style="color: #00ffff;">self</span>).__init__()
        <span style="color: #00ffff;">self</span>.proto = proto

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__getattr__</span>(<span style="color: #00ffff;">self</span>, name):
        <span style="color: #66f;"># </span><span style="color: #66f;">called when attribute has no local definition.</span>
        <span style="color: #00ffff;">return</span> <span style="color: #ff00ff; font-weight: bold;">getattr</span>(<span style="color: #00ffff;">self</span>.proto, name)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__getitem__</span>(<span style="color: #00ffff;">self</span>, key):
        <span style="color: #00ffff;">if</span> key <span style="color: #00ffff;">in</span> <span style="color: #00ffff;">self</span>.keys(): <span style="color: #00ffff;">return</span> <span style="color: #ff00ff; font-weight: bold;">super</span>(World, <span style="color: #00ffff;">self</span>)[key]
        <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.proto[key]

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">changed</span>(<span style="color: #00ffff;">self</span>, key, val):
        <span style="color: #00ff00;">"""Forks a new world, with one key changed."""</span>
        <span style="color: #eedd82;">res</span> = World(<span style="color: #00ffff;">self</span>)
        <span style="color: #eedd82;">res</span>[key] = val
        <span style="color: #00ffff;">return</span> res
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><a id="n0pcnnd1jqg0" name="n0pcnnd1jqg0"></a><span class="section-number-2">7</span> Grammar Interpreter</h2>
<div class="outline-text-2" id="text-7">

<p>
We will assume for now that we have the entire string in memory.
</p>

<div class="org-src-container">

<pre class="src src-python" id="code"><span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Grin</span>(Dispatcher):
    <span style="color: #00ff00;">"""Grammar Interpreter"""</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match</span>(<span style="color: #00ffff;">self</span>, src):
        <span style="color: #00ffff;">self</span>.env = World()
        <span style="color: #00ffff;">self</span>.src, <span style="color: #00ffff;">self</span>.pos, <span style="color: #00ffff;">self</span>.ch = src, 0, <span style="color: #00ff00;">''</span>
        <span style="color: #00ffff;">self</span>.page, <span style="color: #00ffff;">self</span>.line, <span style="color: #00ffff;">self</span>.col = 0, 0, 0
        <span style="color: #00ffff;">for</span> step <span style="color: #00ffff;">in</span> <span style="color: #00ffff;">self</span>.walk(<span style="color: #00ffff;">self</span>.root): <span style="color: #00ffff;">pass</span>

    &lt;&lt;@methods&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><a id="bd6hv400kqg0" name="bd6hv400kqg0"></a><span class="section-number-2">8</span> ebnf in ebnf</h2>
<div class="outline-text-2" id="text-8">
<p>
Here's an grammar for EBNF written in EBNF, so we can test the parser.
</p>

<p>
This text is adapted from <a href="http://www.inf.ethz.ch/personal/wirth/CompilerConstruction/index.html">Compiler Construction</a> by Niklaus Wirth (who invented EBNF, as well as Pascal, Modula, Oberon, and a variety of other languages).
</p>

<div class="org-src-container">

<pre class="src src-prolog" id="ebnf">main = <span style="color: #00ffff;">{</span> rule <span style="color: #00ffff;">}</span> .
rule = <span style="color: #eedd82;">IDENT</span> <span style="color: #00ff00;">"="</span> expr <span style="color: #00ff00;">"."</span> .
expr = term <span style="color: #00ffff;">{</span> <span style="color: #00ff00;">"|"</span> term <span style="color: #00ffff;">}</span> .
term = factor <span style="color: #00ffff;">{</span> factor <span style="color: #00ffff;">}</span> .
factor = <span style="color: #eedd82;">IDENT</span> <span style="color: #00ffff;">|</span> <span style="color: #eedd82;">STRING</span> <span style="color: #00ffff;">|</span> <span style="color: #00ff00;">"{"</span> expr <span style="color: #00ff00;">"}"</span> <span style="color: #00ffff;">|</span> <span style="color: #00ff00;">"["</span> expr <span style="color: #00ff00;">"]"</span> <span style="color: #00ffff;">|</span> <span style="color: #00ff00;">"("</span> expr <span style="color: #00ff00;">")"</span> .
</pre>
</div>

<p>
I placed that code in a block of its own so it would be syntax highlighted, but for python it should be inside a string.
</p>

<div class="org-src-container">

<pre class="src src-python" id="code"><span style="color: #eedd82;">ebnf_src</span> = (
 <span style="color: #00ff00;">'&lt;&lt;ebnf&gt;&gt;'</span>
)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><a id="npdbb4e1jqg0" name="npdbb4e1jqg0"></a><span class="section-number-2">9</span> OUTPUT wejalboot.py</h2>
<div class="outline-text-2" id="text-9">

<p>
And now we can put the whole thing together:
</p>

<pre class="example">
&lt;&lt;@imports&gt;&gt;
&lt;&lt;@code&gt;&gt;
if __name__=="__main__":
    print(Grin(ebnf).match(ebnf_src))
</pre>

<p>
If we try to run this now, here's what we'll get:
</p>

<div class="org-src-container">

<pre class="src src-org"><span style="color: color-208;">wejalboot.py:82:</span> <span style="font-weight: bold;">UserWarning: no handler for tag: Gram</span>
  <span style="color: #00ff00;">yield warn('no handler for tag: %s' % node.__class__.__name__)</span>
<span style="color: #ffd700; font-style: italic;">None</span>
</pre>
</div>

<p>
So now our job is to go back and fill in a handler method for each node until it's able to walk the whole tree.
</p>
</div>
</div>



<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><a id="m3udu291oqg0" name="m3udu291oqg0"></a><span class="section-number-2">10</span> <span class="todo TODO">TODO</span> Input cursor</h2>
<div class="outline-text-2" id="text-10">

<p>
Traditionally, in functional languages, strings are represented as a linked list of characters, which makes them easy to work with recursively.
</p>

<div class="org-src-container">

<pre class="src src-python" id="code"><span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">StringCursor</span>(<span style="color: #ff00ff; font-weight: bold;">object</span>):

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__init__</span>(<span style="color: #00ffff;">self</span>, aString:<span style="color: #ff00ff; font-weight: bold;">str</span>):
        <span style="color: #00ffff;">self</span>.string = s
        <span style="color: #00ffff;">self</span>.pos = -1
        <span style="color: #00ffff;">self</span>.line= 0
        <span style="color: #00ffff;">self</span>.fwd()

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">fwd</span>(<span style="color: #00ffff;">self</span>):
        <span style="color: #00ffff;">self</span>.pos += 1
        <span style="color: #00ffff;">self</span>.ch
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><a id="x88gff91oqg0" name="x88gff91oqg0"></a><span class="section-number-2">11</span> Data structure for parse results.</h2>
<div class="outline-text-2" id="text-11">

<p>
The output format will be almost the same as the input format.
</p>

<div class="org-src-container">

<pre class="src src-python" id="code"><span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Fail</span>(<span style="color: #ff00ff; font-weight: bold;">object</span>): <span style="color: #00ff00;">"""Value to indicate failure."""</span>
<span style="color: #eedd82;">FAIL</span> = Fail()
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><a id="yg99mk91oqg0" name="yg99mk91oqg0"></a><span class="section-number-2">12</span> Inference Rules</h2>
<div class="outline-text-2" id="text-12">

<div class="org-src-container">

<pre class="src src-python" id="methods"><span style="color: #66f;"># </span><span style="color: #66f;">(inside  `class Grin`...)</span>
<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">onRef</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #00ffff;">raise</span> <span style="color: #ff00ff;">NotImplementedError</span>(<span style="color: #00ff00;">'no nonterminal references yet.'</span>)

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">onEmp</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #00ffff;">return</span> (<span style="color: #ffaf00;">None</span>, cur, env)

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">onLit</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #00ffff;">if</span> cur.value == node.item: <span style="color: #00ffff;">return</span> (cur.value, cur.fwd(), env)
    <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> (FAIL, cur, env)

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">onSeq</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #00ffff;">for</span> item <span style="color: #00ffff;">in</span> node.body:
        <span style="color: #eedd82;">tup</span> = <span style="color: #00ffff;">self</span>.walk(item, cur, env)
        <span style="color: #00ffff;">if</span> tup[0] <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">return</span> (FAIL, tup[1])
        <span style="color: #00ffff;">else</span>: <span style="color: #eedd82;">val</span>, <span style="color: #eedd82;">cur</span>, <span style="color: #eedd82;">env</span> = tup
    <span style="color: #66f;"># </span><span style="color: #66f;">if it didn't fail, return the last value:</span>
    <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> (val, cur, env)

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">onAlt</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #00ffff;">for</span> item <span style="color: #00ffff;">in</span> node.body:
        <span style="color: #eedd82;">tup</span> = <span style="color: #00ffff;">self</span>.walk(item, cur, env)
        <span style="color: #00ffff;">if</span> tup[0] <span style="color: #00ffff;">is</span> FAIL: <span style="color: #eedd82;">env</span> = tup[1]
        <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> tup
    <span style="color: #00ffff;">return</span> tup <span style="color: #66f;"># </span><span style="color: #66f;">last failure</span>

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">onOrp</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #eedd82;">vals</span> = []
    <span style="color: #00ffff;">while</span> <span style="color: #ffaf00;">True</span>:
        <span style="color: #eedd82;">tup</span> = <span style="color: #00ffff;">self</span>.walk(node.item, cur, env)
        <span style="color: #00ffff;">if</span> tup[0] <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">break</span>
        <span style="color: #00ffff;">else</span>:
            <span style="color: #eedd82;">val</span>, <span style="color: #eedd82;">cur</span>, <span style="color: #eedd82;">env</span> = tup
            vals.append(val)
    <span style="color: #00ffff;">return</span> (vals, cur, env)

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">onNot</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #eedd82;">tup</span> = <span style="color: #00ffff;">self</span>.walk(node.item, cur, env)
    <span style="color: #00ffff;">if</span> tup[0] <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">return</span> (<span style="color: #ffaf00;">None</span>, cur, tup[1])
    <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> (FAIL, tup[1])

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">onVar</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #eedd82;">tup</span> = <span style="color: #00ffff;">self</span>.walk(node.item, cur, env)
    <span style="color: #00ffff;">if</span> tup[0] <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">return</span> tup
    <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> (tup[0], cur, env.changed(node.name, tup[0])

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">onAct</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #00ffff;">raise</span> <span style="color: #ff00ff;">NotImplementedError</span>(<span style="color: #00ff00;">'no semantic actions yet.'</span>)

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">onCell</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #00ffff;">raise</span> <span style="color: #ff00ff;">NotImplementedError</span>(<span style="color: #00ff00;">'no tree matching yet.'</span>)
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><a id="ks01bt30kqg0" name="ks01bt30kqg0"></a><span class="section-number-2">13</span> Compilation step.</h2>
<div class="outline-text-2" id="text-13">

<div class="org-src-container">

<pre class="src src-python" id="methods"><span style="color: #66f;"># </span><span style="color: #66f;">(still inside  `class Grin`...)</span>
<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">onGram</span>(<span style="color: #00ffff;">self</span>, node):
    <span style="color: #00ffff;">self</span>.defs = {}
    <span style="color: #00ffff;">for</span> child <span style="color: #00ffff;">in</span> node.body: <span style="color: #00ffff;">yield</span> <span style="color: #00ffff;">from</span> <span style="color: #00ffff;">self</span>.walk(child)

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">onDef</span>(<span style="color: #00ffff;">self</span>, node):
    <span style="color: #00ffff;">raise</span> <span style="color: #ff00ff;">NotImplementedError</span>(<span style="color: #00ff00;">'TODO: onDef (and others)...'</span>)
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14"><a id="hnv0l310pqg0" name="hnv0l310pqg0"></a><span class="section-number-2">14</span> <span class="todo TODO">TODO</span> credits</h2>
<div class="outline-text-2" id="text-14">
<ul class="org-ul">
<li>grammar rules are adapted from Alessandro Warth's <a href="http://tinlizzie.org/ometa/">Ometa</a> system.
</li>
</ul>
</div>
</div>
</div>
</body>
</html>
