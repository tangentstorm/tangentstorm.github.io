<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-04-17 Sun 17:34 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>wejal bootstrap</title>
<meta  name="generator" content="Org-mode" />
<link rel="stylesheet" type="text/css" href="/etc/style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">wejal bootstrap</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. A Grammar Interpreter</a></li>
<li><a href="#orgheadline2">2. Grammar Combinators</a></li>
<li><a href="#orgheadline3">3. Generic dispatch</a></li>
<li><a href="#orgheadline4">4. Input cursor</a></li>
<li><a href="#orgheadline5">5. Data structure for parse results.</a></li>
<li><a href="#orgheadline6">6. Simple pattern matching.</a></li>
<li><a href="#orgheadline7">7. Regular Expressions</a></li>
<li><a href="#orgheadline8">8. Tokenization</a></li>
<li><a href="#orgheadline9">9. EBNF</a></li>
<li><a href="#orgheadline10">10. A Bootstrap tokenizer.</a></li>
<li><a href="#orgheadline11">11. <span class="todo nilTODO">TODO</span> -&#x2014; clean up below here ----</a></li>
<li><a href="#orgheadline12">12. Strategy</a></li>
<li><a href="#orgheadline13">13. Manually build a base grammar to provide generic tokenization.</a></li>
<li><a href="#orgheadline14">14. Now define the bootstrap grammar to parse EBNF grammar definitions.</a></li>
<li><a href="#orgheadline15">15. Worlds for backtracking.</a></li>
<li><a href="#orgheadline16">16. Grammar Interpreter</a></li>
<li><a href="#orgheadline17">17. OUTPUT wejalboot.py</a></li>
<li><a href="#orgheadline18">18. Inference Rules</a></li>
<li><a href="#orgheadline19">19. Compilation step.</a></li>
<li><a href="#orgheadline20">20. <span class="todo nilTODO">TODO</span> credits</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><a id="7zli6i3147h0"></a><span class="section-number-2">1</span> A Grammar Interpreter</h2>
<div class="outline-text-2" id="text-1">
<p>
Our goal is to bootstrap an interpreter for a new programming language.
We would like to build it incrementally from the ground up.
</p>

<p>
Rather than writing a parser by hand, we would like to model the language syntax and semantics as data, and pass this data to a generic <i>grammar interpreter</i>.
</p>

<p>
We will build the grammar interpreter incrementally, with test cases.
</p>

<p>
For starters, we will focus on simple regular expressions:, much like python's built-in <code>re</code> module.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock1">&gt;&gt;&gt; <span style="color: #eedd82;">m</span> = Matcher(Alt([Lit(<span style="color: #00ff00;">"x"</span>), Lit(<span style="color: #00ff00;">"y"</span>)])) <span style="color: #66f;"># </span><span style="color: #66f;">like re.compile("x|y")</span>
&gt;&gt;&gt; m.match(<span style="color: #00ff00;">'xyz'</span>)                         <span style="color: #66f;"># </span><span style="color: #66f;">should match "x" at position 0</span>
Match(txt=<span style="color: #00ff00;">'x'</span>, pos=0)
&gt;&gt;&gt; m.match(<span style="color: #00ff00;">"zyx"</span>)                         <span style="color: #66f;"># </span><span style="color: #66f;">should fail to match</span>
FAIL
</pre>
</div>

<p>
Obviously, the concise syntax provided by the <code>re</code> module is nicer than building pattern structures by hand. We will address this soon by bootstrapping our own parser for grammar definitions. In the meantime, we will build our rule definitions by building data structures with python's <code>namedtuple</code>.
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><a id="9906u111jqg0"></a><span class="section-number-2">2</span> Grammar Combinators</h2>
<div class="outline-text-2" id="text-2">
<p>
Here are our data types for modeling grammar definitions. Since we are using <code>namedtuple</code>, there is no actual behavior associated with them. They're just constructors we can manually compose to create data structures.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock2"><span style="color: #00ffff;">from</span> collections <span style="color: #00ffff;">import</span> namedtuple
</pre>
</div>
<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock3"><span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">T</span>(tag, doc, args):
    <span style="color: #00ff00;">"""Creates a new tuple type."""</span>
    <span style="color: #eedd82;">res</span> = namedtuple(tag, args)
    <span style="color: #00ffff;">if</span> doc: res.<span style="color: #ff00ff; font-weight: bold;">__doc__</span>+=<span style="color: #00ff00;">' : '</span>+doc
    <span style="color: #00ffff;">return</span> res

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">TB</span>(tag, doc, args=[<span style="color: #00ff00;">'body'</span>]): <span style="color: #00ffff;">return</span> T(tag, doc, args)
<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">TI</span>(tag, doc, args=[<span style="color: #00ff00;">'item'</span>]): <span style="color: #00ffff;">return</span> T(tag, doc, args)
<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">TN</span>(tag, doc, args=[<span style="color: #00ff00;">'name'</span>]): <span style="color: #00ffff;">return</span> T(tag, doc, args)
<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">T2</span>(tag, doc, args=[<span style="color: #00ff00;">'name'</span>,<span style="color: #00ff00;">'body'</span>]): <span style="color: #00ffff;">return</span> T(tag, doc, args)

<span style="color: #eedd82;">Gram</span> = T(<span style="color: #00ff00;">'Gram'</span>, <span style="color: #00ff00;">'contains grammar rules (may inherit from `bases`).'</span>,
         [<span style="color: #00ff00;">'name'</span>, <span style="color: #00ff00;">'bases'</span>, <span style="color: #00ff00;">'doc'</span>, <span style="color: #00ff00;">'body'</span>])
<span style="color: #eedd82;">Def</span> = T(<span style="color: #00ff00;">'Def'</span>, <span style="color: #00ff00;">'define a named rule.'</span>, [<span style="color: #00ff00;">'name'</span>,<span style="color: #00ff00;">'body'</span>])
<span style="color: #eedd82;">Ref</span> = TN(<span style="color: #00ff00;">'Ref'</span>, <span style="color: #00ff00;">'refer to (invoke) a named rule'</span>)

<span style="color: #eedd82;">Any</span> = T(<span style="color: #00ff00;">'Any'</span>, <span style="color: #00ff00;">'match anything'</span>, [])
<span style="color: #eedd82;">Not</span> = TI(<span style="color: #00ff00;">'Not'</span>, <span style="color: #00ff00;">'fail if the pattern would match, but do not consume'</span>)
<span style="color: #eedd82;">Skip</span> = TI(<span style="color: #00ff00;">'Skip'</span>, <span style="color: #00ff00;">'match the pattern, but hide it from other rules'</span>)

<span style="color: #eedd82;">Emp</span> = T(<span style="color: #00ff00;">'Emp'</span>, <span style="color: #00ff00;">'empty pattern (always matches)'</span>, [])
<span style="color: #eedd82;">Emp</span> = Emp() <span style="color: #66f;"># </span><span style="color: #66f;">since it doesn't need arguments</span>

<span style="color: #eedd82;">Lit</span> = TI(<span style="color: #00ff00;">'Lit'</span>, <span style="color: #00ff00;">'match literal character (using ==)'</span>)
<span style="color: #eedd82;">Str</span> = TI(<span style="color: #00ff00;">'Str'</span>, <span style="color: #00ff00;">'match a string of literals'</span>)
<span style="color: #eedd82;">Seq</span> = TB(<span style="color: #00ff00;">'Seq'</span>, <span style="color: #00ff00;">'match a sequence of patterns'</span>)
<span style="color: #eedd82;">Grp</span> = TB(<span style="color: #00ff00;">'Grp'</span>, <span style="color: #00ff00;">'same as Seq, but renders in parentheses'</span>)
<span style="color: #eedd82;">Alt</span> = TB(<span style="color: #00ff00;">'Alt'</span>, <span style="color: #00ff00;">'match any of the alternatives'</span>)
<span style="color: #eedd82;">Rep</span> = TI(<span style="color: #00ff00;">'Rep'</span>, <span style="color: #00ff00;">'match 1 or more repetitions.'</span>)
<span style="color: #eedd82;">Opt</span> = TI(<span style="color: #00ff00;">'Opt'</span>, <span style="color: #00ff00;">'match 0 or 1 repetitions.'</span>)
<span style="color: #eedd82;">Orp</span> = TI(<span style="color: #00ff00;">'Orp'</span>, <span style="color: #00ff00;">'match 0 or more repetitions.'</span>)

<span style="color: #eedd82;">Var</span> = T2(<span style="color: #00ff00;">'Var'</span>, <span style="color: #00ff00;">'save matched string in a variable.'</span>)
<span style="color: #eedd82;">Val</span> = TN(<span style="color: #00ff00;">'Val'</span>, <span style="color: #00ff00;">'match against the saved value.'</span>)
<span style="color: #eedd82;">New</span> = T2(<span style="color: #00ff00;">'New'</span>, <span style="color: #00ff00;">'build a new class/tuple instance'</span>)
<span style="color: #eedd82;">Arg</span> = TB(<span style="color: #00ff00;">'Arg'</span>, <span style="color: #00ff00;">'pass matched data as arg to containing "New"'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3"><a id="w0bhd8b1jqg0"></a><span class="section-number-2">3</span> Generic dispatch</h2>
<div class="outline-text-2" id="text-3">
<p>
Since we will be composing instances of these types into trees, and want our system to interpret the types differently, we need a way to map each type to an appropriate handler.
</p>

<p>
We will imlement this using a base class that simply maps each <code>namedtuple</code> type to a method with the same name (and a given prefix).
</p>

<p>
In other words, when we see an <code>Alt</code> node in the tree, we can use this to automatically invoke a method in our interpreter class called <code>match_Alt</code>.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock4"><span style="color: #00ffff;">from</span> warnings <span style="color: #00ffff;">import</span> warn
</pre>
</div>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock5"><span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">node_type</span>(node):
    <span style="color: #00ffff;">return</span> node.__class__.<span style="color: #ff00ff; font-weight: bold;">__name__</span>

<span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Dispatcher</span>:
    <span style="color: #00ff00;">"""Provides a simple generic dispatch mechanism based on method names"""</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">_find_handler</span>(<span style="color: #00ffff;">self</span>, prefix, node):
        <span style="color: #00ff00;">"""(prefix, namedtuple) -&gt; callable"""</span>
        <span style="color: #00ffff;">return</span> <span style="color: #ff00ff; font-weight: bold;">getattr</span>(<span style="color: #00ffff;">self</span>, <span style="color: #00ff00;">'_'</span>.join([prefix, node_type(node)]), <span style="color: #00ffff;">self</span>._unhandled)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">_unhandled</span>(<span style="color: #00ffff;">self</span>, node, *a, **kw):
        <span style="color: #00ff00;">"""Warn about unrecognized node types. (Just for development.)"""</span>
        <span style="color: #00ffff;">raise</span> <span style="color: #ff00ff;">ValueError</span>(<span style="color: #00ff00;">"no handler found for %s"</span> % node_type(node))

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">dispatch</span>(<span style="color: #00ffff;">self</span>, prefix, node, *a, **kw):
        <span style="color: #00ff00;">"""Find and invoke a handler for the given node."""</span>
        <span style="color: #eedd82;">h</span> = <span style="color: #00ffff;">self</span>._find_handler(prefix, node)
        <span style="color: #00ffff;">return</span> h(node, *a, **kw)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4"><a id="m3udu291oqg0"></a><span class="section-number-2">4</span> Input cursor</h2>
<div class="outline-text-2" id="text-4">
<p>
We also need to keep track of where we are in the input sequence.
The following helper class will do the work for us:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock6"><span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Cursor</span>:

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__init__</span>(<span style="color: #00ffff;">self</span>, seq:[<span style="color: #ff00ff; font-weight: bold;">any</span>]):
        <span style="color: #00ffff;">self</span>.seq = seq    <span style="color: #66f;"># </span><span style="color: #66f;">sequence (probably a string)</span>
        <span style="color: #00ffff;">self</span>.val = <span style="color: #ffaf00;">None</span>   <span style="color: #66f;"># </span><span style="color: #66f;">current value</span>
        <span style="color: #00ffff;">self</span>.pos = -1     <span style="color: #66f;"># </span><span style="color: #66f;">current position</span>
        <span style="color: #00ffff;">self</span>.fwd()

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">fwd</span>(<span style="color: #00ffff;">self</span>)-&gt;<span style="color: #ff00ff; font-weight: bold;">any</span>:
        <span style="color: #00ff00;">"""Move forward in the sequence and return the next item."""</span>
        <span style="color: #eedd82;">end</span> = <span style="color: #ff00ff; font-weight: bold;">len</span>(<span style="color: #00ffff;">self</span>.seq)
        <span style="color: #00ffff;">self</span>.pos = <span style="color: #ff00ff; font-weight: bold;">min</span>(<span style="color: #00ffff;">self</span>.pos+1, end)
        <span style="color: #00ffff;">self</span>.val = <span style="color: #ffaf00;">None</span> <span style="color: #00ffff;">if</span> <span style="color: #00ffff;">self</span>.pos == end <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">self</span>.seq[<span style="color: #00ffff;">self</span>.pos] 
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">at_end</span>(<span style="color: #00ffff;">self</span>)-&gt;<span style="color: #ff00ff; font-weight: bold;">bool</span>:
        <span style="color: #00ff00;">"""Are we at the end of the sequence?"""</span>
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.val <span style="color: #00ffff;">is</span> <span style="color: #ffaf00;">None</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5"><a id="x88gff91oqg0"></a><span class="section-number-2">5</span> Data structure for parse results.</h2>
<div class="outline-text-2" id="text-5">
<p>
Matching should either produce:
</p>

<p>
&#x2026; A match object, which stores the matched text, and its position within the input:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock7"><span style="color: #eedd82;">Match</span> = namedtuple(<span style="color: #00ff00;">"Match"</span>, [<span style="color: #00ff00;">'txt'</span>, <span style="color: #00ff00;">'pos'</span>])
Match.<span style="color: #ff00ff; font-weight: bold;">__doc__</span> = <span style="color: #00ff00;">"Match Result"</span>
</pre>
</div>

<p>
&#x2026; Or, a special constant called <code>FAIL</code>:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock8"><span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Fail</span>:
    <span style="color: #00ff00;">"""Value to indicate failure."""</span>
    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__repr__</span>(<span style="color: #00ffff;">self</span>):
        <span style="color: #00ffff;">return</span> <span style="color: #00ff00;">"FAIL"</span>
<span style="color: #eedd82;">FAIL</span> = Fail()
</pre>
</div>

<p>
We are also going to use a namedtuple to represent the match state at any given time.
This state includes the match result, a cursor marking the position in the string, and an environment (which we will use later on for storing state). 
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock9"><span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">M</span>(namedtuple(<span style="color: #00ff00;">"M"</span>, [<span style="color: #00ff00;">'val'</span>, <span style="color: #00ff00;">'cur'</span>, <span style="color: #00ff00;">'env'</span>])):
    <span style="color: #00ff00;">"""Internal Match State"""</span>

    <span style="color: #ff00ff;">@property</span>
    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">matched</span>(<span style="color: #00ffff;">self</span>):
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.val <span style="color: #00ffff;">is</span> <span style="color: #00ffff;">not</span> FAIL
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6"><a id="yba9ij4147h0"></a><span class="section-number-2">6</span> Simple pattern matching.</h2>
<div class="outline-text-2" id="text-6">
<p>
Now we can start building the matcher. First we will set up the <code>Dispatch</code> stuff:  
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock10"><span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Matcher</span>(Dispatcher):
    <span style="color: #00ff00;">"""</span>
<span style="color: #00ff00;">    A simple matcher for regular languages.</span>
<span style="color: #00ff00;">    &lt;&lt;@doctests.matcher&gt;&gt;</span>
<span style="color: #00ff00;">    """</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__init__</span>(<span style="color: #00ffff;">self</span>, node):
        <span style="color: #00ffff;">self</span>.root = node

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">_match</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ff00;">"""returns a match state tuple (the `M` class)"""</span>
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.dispatch(<span style="color: #00ff00;">'match'</span>, node, cur, env)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match</span>(<span style="color: #00ffff;">self</span>, s:<span style="color: #ff00ff; font-weight: bold;">str</span>):
        <span style="color: #eedd82;">cur</span> = Cursor(s)
        <span style="color: #eedd82;">env</span> = {}
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>._match(<span style="color: #00ffff;">self</span>.root, cur, env).val
</pre>
</div>

<p>
Now we are ready to implement the handlers for our initial example:
</p>

<p>
The simplest case is comparison against a single literal character (<code>Lit</code>):
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock11"><span style="color: #66f;"># </span><span style="color: #66f;">class Matcher:</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Lit</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">return</span> (M(Match(cur.val, cur.pos), cur.fwd(), env) <span style="color: #00ffff;">if</span> cur.val == node.item
                <span style="color: #00ffff;">else</span> M(FAIL, cur, env))
</pre>
</div>


<p>
For <code>Alt</code>, we just try matching each alternative, in sequence.
</p>

<p>
Note that only the <i>first</i> matching pattern is returned.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock12"><span style="color: #66f;"># </span><span style="color: #66f;">class Matcher:</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Alt</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">for</span> item <span style="color: #00ffff;">in</span> node.body:
            <span style="color: #eedd82;">m</span> = <span style="color: #00ffff;">self</span>._match(item, cur, env)
            <span style="color: #00ffff;">if</span> m.matched: <span style="color: #00ffff;">return</span> m
        <span style="color: #00ffff;">return</span> m <span style="color: #66f;"># </span><span style="color: #66f;">last failure</span>
</pre>
</div>

<p>
At this point, our original example using <code>Alt([ Lit('x'), Lit('y') ])</code> works as advertised.
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7"><a id="9u58i7e147h0"></a><span class="section-number-2">7</span> Regular Expressions</h2>
<div class="outline-text-2" id="text-7">
<p>
With <code>Lit</code> and <code>Alt</code> out of the way, only need a few more cases to allow full regular expressions:
</p>

<p>
<code>Emp</code> matches the empty string. It takes no arguments, and always succeeds:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock13">&gt;&gt;&gt; Matcher(Emp).match(<span style="color: #00ff00;">"hello"</span>)
Match(txt=<span style="color: #00ff00;">''</span>, pos=0)
</pre>
</div>

<p>
<code>Seq</code> takes a list of patterns and matches all of them in sequence.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock14">&gt;&gt;&gt; <span style="color: #eedd82;">m</span> = Matcher(Seq([Lit(<span style="color: #00ff00;">"a"</span>), Alt([Lit(<span style="color: #00ff00;">"a"</span>), Lit(<span style="color: #00ff00;">"b"</span>)])]))
&gt;&gt;&gt; m.match(<span style="color: #00ff00;">"ab"</span>)
Match(txt=<span style="color: #00ff00;">'ab'</span>, pos=0)
&gt;&gt;&gt; m.match(<span style="color: #00ff00;">"ac"</span>)
FAIL
</pre>
</div>

<p>
As a special case, <code>Str</code> matches a string of literals:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock15">&gt;&gt;&gt; Matcher(Str(<span style="color: #00ff00;">"hello"</span>)).match(<span style="color: #00ff00;">"hello"</span>)
Match(txt=<span style="color: #00ff00;">'hello'</span>, pos=0)
</pre>
</div>

<p>
<code>Rep</code> matches one or more repetitions of a pattern. It works like <code>+</code> in regular expressions.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock16">&gt;&gt;&gt; Matcher(Rep(Lit(<span style="color: #00ff00;">"a"</span>))).match(<span style="color: #00ff00;">"aaabbbccc"</span>)
Match(txt=<span style="color: #00ff00;">'aaa'</span>, pos=0)
</pre>
</div>

<p>
<code>Opt</code> indicates that a match is optional. <code>Opt(x)</code> is equivalent to <code>Alt([x, Emp])</code>. It works like <code>?</code> in regular expressions.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock17">&gt;&gt;&gt; <span style="color: #eedd82;">m</span> = Matcher(Opt(Lit(<span style="color: #00ff00;">"a"</span>)))
&gt;&gt;&gt; m.match(<span style="color: #00ff00;">"abc"</span>)
Match(txt=<span style="color: #00ff00;">'a'</span>, pos=0)
&gt;&gt;&gt; m.match(<span style="color: #00ff00;">"xyz"</span>)
Match(txt=<span style="color: #00ff00;">''</span>, pos=0)
</pre>
</div>

<p>
<code>Orp(x)</code> is shorthand for <code>Opt(Rep(x))</code>, and works like <code>*</code> in regular expressions.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock18">&gt;&gt;&gt; <span style="color: #eedd82;">m</span> = Matcher(Orp(Lit(<span style="color: #00ff00;">"a"</span>)))
&gt;&gt;&gt; m.match(<span style="color: #00ff00;">"aaabc"</span>)
Match(txt=<span style="color: #00ff00;">'aaa'</span>, pos=0)
&gt;&gt;&gt; m.match(<span style="color: #00ff00;">"xyz"</span>)
Match(txt=<span style="color: #00ff00;">''</span>, pos=0)
</pre>
</div>

<p>
If you prefer, you could treat <code>Orp</code> as the more primitive operation, and <code>Rep(x)</code> as sugar for <code>Seq([x, Orp(x)])</code>, but the following implementation uses the rules above:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock19"><span style="color: #66f;"># </span><span style="color: #66f;">class Matcher:</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Emp</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">return</span> M(Match(<span style="color: #00ff00;">""</span>, cur.pos), cur, env)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">_join</span>(<span style="color: #00ffff;">self</span>, matches):
        <span style="color: #00ff00;">"""helper to join match results for Seq and Str"""</span>
        <span style="color: #00ffff;">if</span> matches <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">return</span> FAIL
        <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> Match(<span style="color: #00ff00;">''</span>.join(v.txt <span style="color: #00ffff;">for</span> v <span style="color: #00ffff;">in</span> matches), matches[0].pos)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Seq</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #eedd82;">vals</span> = []
        <span style="color: #00ffff;">for</span> item <span style="color: #00ffff;">in</span> node.body:
            <span style="color: #eedd82;">res</span> = <span style="color: #00ffff;">self</span>._match(item, cur, env)
            <span style="color: #00ffff;">if</span> res.val <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">return</span> M(FAIL, res.cur, env)
            <span style="color: #00ffff;">else</span>:
                <span style="color: #eedd82;">val</span>, <span style="color: #eedd82;">cur</span>, <span style="color: #eedd82;">env</span> = res
                vals.append(val)
        <span style="color: #00ffff;">return</span> M(<span style="color: #00ffff;">self</span>._join(vals), res.cur, env)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Str</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>._match(Seq([Lit(c) <span style="color: #00ffff;">for</span> c <span style="color: #00ffff;">in</span> node.item]), cur, env)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Rep</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #eedd82;">vals</span> = []
        <span style="color: #00ffff;">while</span> <span style="color: #ffaf00;">True</span>:
            <span style="color: #eedd82;">res</span> = <span style="color: #00ffff;">self</span>._match(node.item, cur, env)
            <span style="color: #00ffff;">if</span> res.val <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">break</span>
            <span style="color: #00ffff;">else</span>:
                <span style="color: #eedd82;">val</span>, <span style="color: #eedd82;">cur</span>, <span style="color: #eedd82;">env</span> = res
                vals.append(val)
        <span style="color: #00ffff;">return</span> M(<span style="color: #00ffff;">self</span>._join(vals <span style="color: #00ffff;">or</span> FAIL), cur, env)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Opt</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>._match(Alt([node.item, Emp]), cur, env)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Orp</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>._match(Opt(Rep(node.item)), cur, env)
</pre>
</div>

<p>
Most modern regular expression engines support additions like groups and backreferences. We will diverge a bit here, though, because we are interested in writing full parsers, with mutually recursive named rules.
</p>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8"><a id="ua87gur077h0"></a><span class="section-number-2">8</span> Tokenization</h2>
<div class="outline-text-2" id="text-8">
<p>
While not strictly required, it's traditional to break parsing up into two phases: the first pass scans through the text and breaks it up into tokens, a process called tokenization or lexing.The second pass parses the stream of tokens and (at least conceptually) constructs a tree-like structure. 
</p>

<p>
Our version of tokens will just be tuples strings, tagged with rule names and match positions:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock20">&gt;&gt;&gt; <span style="color: #eedd82;">s</span> = Scanner([(<span style="color: #00ff00;">"a+"</span>, Rep(Lit(<span style="color: #00ff00;">"a"</span>))), (<span style="color: #00ff00;">"b+"</span>, Rep(Lit(<span style="color: #00ff00;">"b"</span>)))])
&gt;&gt;&gt; s.scan(<span style="color: #00ff00;">"abaabb"</span>)
[(<span style="color: #00ff00;">'a'</span>, <span style="color: #00ff00;">'a+'</span>, 0), (<span style="color: #00ff00;">'b'</span>, <span style="color: #00ff00;">'b+'</span>, 1), (<span style="color: #00ff00;">'aa'</span>, <span style="color: #00ff00;">'a+'</span>, 2), (<span style="color: #00ff00;">'bb'</span>, <span style="color: #00ff00;">'b+'</span>, 4)]

&gt;&gt;&gt; s.scan(<span style="color: #00ff00;">"a b   \t bb a"</span>)  <span style="color: #66f;"># </span><span style="color: #66f;">whitespace is ignored by default.</span>
[(<span style="color: #00ff00;">'a'</span>, <span style="color: #00ff00;">'a+'</span>, 0), (<span style="color: #00ff00;">'b'</span>, <span style="color: #00ff00;">'b+'</span>, 2), (<span style="color: #00ff00;">'bb'</span>, <span style="color: #00ff00;">'b+'</span>, 8), (<span style="color: #00ff00;">'a'</span>, <span style="color: #00ff00;">'a+'</span>,  11)]
</pre>
</div>


<p>
Our implementation is incredibly naive: it just keeps looping through the list of rules and trying to match each one.
</p>

<p>
Later on, we can improve the performance by compiling the rules into a state machine, but we will stick with something simple while we're bootstrapping the rest of the system:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock21"><span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Scanner</span>:

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__init__</span>(<span style="color: #00ffff;">self</span>, rules: [(<span style="color: #ff00ff; font-weight: bold;">str</span>, namedtuple)]):
        <span style="color: #00ffff;">self</span>.order = [rule[0] <span style="color: #00ffff;">for</span> rule <span style="color: #00ffff;">in</span> rules]  <span style="color: #66f;"># </span><span style="color: #66f;">test rules in given order</span>
        <span style="color: #00ffff;">self</span>.rules = <span style="color: #ff00ff; font-weight: bold;">dict</span>(rules)
        <span style="color: #66f;"># </span><span style="color: #66f;">default whitespace handler:</span>
        <span style="color: #00ffff;">if</span> <span style="color: #00ff00;">'_'</span> <span style="color: #00ffff;">not</span> <span style="color: #00ffff;">in</span> rules:
            <span style="color: #00ffff;">self</span>.order.insert(0, <span style="color: #00ff00;">'_'</span>)
            <span style="color: #00ffff;">self</span>.rules[<span style="color: #00ff00;">'_'</span>] = Alt([Lit(<span style="color: #ff00ff; font-weight: bold;">chr</span>(i)) <span style="color: #00ffff;">for</span> i <span style="color: #00ffff;">in</span> <span style="color: #ff00ff; font-weight: bold;">range</span>(33)])

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">gen_tokens</span>(<span style="color: #00ffff;">self</span>, txt):
        <span style="color: #eedd82;">cur</span> = Cursor(txt)
        <span style="color: #eedd82;">env</span> = {}
        <span style="color: #eedd82;">matcher</span> = Matcher(Emp)
        <span style="color: #00ffff;">while</span> <span style="color: #00ffff;">not</span> cur.at_end():
            <span style="color: #00ffff;">for</span> rule <span style="color: #00ffff;">in</span> <span style="color: #00ffff;">self</span>.order:
                <span style="color: #eedd82;">m</span> = matcher._match(<span style="color: #00ffff;">self</span>.rules[rule], cur, env)
                <span style="color: #00ffff;">if</span> m.matched:
                    <span style="color: #eedd82;">match</span>, <span style="color: #eedd82;">cur</span>, <span style="color: #eedd82;">env</span> = m
                    <span style="color: #00ffff;">if</span> rule != <span style="color: #00ff00;">'_'</span>:
                        <span style="color: #00ffff;">yield</span> (match.txt, rule, match.pos)
                    <span style="color: #00ffff;">break</span>
                <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">continue</span>
            <span style="color: #00ffff;">else</span>:
                <span style="color: #00ffff;">raise</span> <span style="color: #ff00ff;">ValueError</span>(<span style="color: #00ff00;">"unrecognized character at position %i : '%s'"</span>
                                 % (cur.pos, cur.val))

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">scan</span>(<span style="color: #00ffff;">self</span>, txt):
        <span style="color: #00ffff;">return</span> <span style="color: #ff00ff; font-weight: bold;">list</span>(<span style="color: #00ffff;">self</span>.gen_tokens(txt))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-2">
<h2 id="orgheadline9"><a id="bd6hv400kqg0"></a><span class="section-number-2">9</span> EBNF</h2>
<div class="outline-text-2" id="text-9">
<p>
We are about to extend the simple string matcher to a full parsing system.
</p>

<p>
One thing we would like to be able to parse is a nicer syntax for building grammars.
</p>

<p>
There are various languages for writing grammars. We will use one called 'EBNF', which is an acronym for <i>Extended Backus-Naur Form</i>).
</p>

<p>
Here's a grammar for EBNF written in EBNF, so we can test the parser.
</p>

<div class="org-src-container">

<pre class="src src-prolog" id="orgsrcblock22">main = <span style="color: #00ffff;">{</span> rule <span style="color: #00ffff;">}</span> .
rule = <span style="color: #eedd82;">IDENT</span> <span style="color: #00ff00;">"="</span> expr <span style="color: #00ff00;">"."</span> .
expr = term <span style="color: #00ffff;">{</span> <span style="color: #00ff00;">"|"</span> term <span style="color: #00ffff;">}</span> .
term = factor <span style="color: #00ffff;">{</span> factor <span style="color: #00ffff;">}</span> .
factor = <span style="color: #eedd82;">IDENT</span> <span style="color: #00ffff;">|</span> <span style="color: #eedd82;">STRING</span> <span style="color: #00ffff;">|</span> <span style="color: #00ff00;">"{"</span> expr <span style="color: #00ff00;">"}"</span> <span style="color: #00ffff;">|</span> <span style="color: #00ff00;">"["</span> expr <span style="color: #00ff00;">"]"</span> <span style="color: #00ffff;">|</span> <span style="color: #00ff00;">"("</span> expr <span style="color: #00ff00;">")"</span> .
</pre>
</div>

<p>
This definition is adapted from <a href="http://www.inf.ethz.ch/personal/wirth/CompilerConstruction/index.html">Compiler Construction</a> by Niklaus Wirth (who invented EBNF, as well as Pascal, Modula, Oberon, and a variety of other languages).
</p>

<p>
It is self describing. The <code>{...}</code> syntax corresponds to <code>Orp(Seq(...))</code> in our world. The <code>|</code> is placed between alternatives, and the characters in quotes correspond to <code>Lit</code>.
</p>

<p>
The <code>[...]</code> syntax defined in the <code>factor</code> rule isn't actually used by this grammar, but it corresponds to <code>Opt(...)</code>. The <code>(...)</code> syntax corresponds to <code>Seq(...)</code>. These can of course be nested inside each other to arbitrary depths.
</p>

<p>
The lower case names correspond to rule definitions and references to those rules. These are <code>Def</code> and <code>Ref</code> in our system &#x2013; we'll be covering those soon.
</p>

<p>
The upper case names refer to token types. A <code>STRING</code> is just a sequence of characters between double quotes, and an <code>IDENT</code> just means a sequence of english letters.
</p>

<p>
I placed the definition code in a block of its own so it would be syntax highlighted, but for python it should be inside a string:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock23"><span style="color: #eedd82;">ebnf_src</span> = <span style="color: #00ff00;">'''\</span>
<span style="color: #00ff00;">&lt;&lt;ebnf&gt;&gt;</span>
<span style="color: #00ff00;">'''</span>
</pre>
</div>

<p>
Our next major goal will be to parse grammars like these. First, we will manually create a tokenizer for this language, then we will extend the matcher with <code>Def</code> and <code>Ref</code> and the ability to match tokens rather than just strings. Then we will manually translate the above EBNF definition into a data structure built that we can pass to the grammar interpreter.
</p>
</div>
</div>


<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10"><a id="0zsa4ty077h0"></a><span class="section-number-2">10</span> A Bootstrap tokenizer.</h2>
<div class="outline-text-2" id="text-10">
<p>
With the tools we have now, there's really not much work to define a scanner for EBNF:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock24"><span style="color: #eedd82;">ECHR</span>, <span style="color: #eedd82;">SQ</span>, <span style="color: #eedd82;">DQ</span> = [<span style="color: #00ff00;">'\\'</span>, <span style="color: #00ff00;">"'"</span>, <span style="color: #00ff00;">'"'</span>]
<span style="color: #eedd82;">LETTER</span> = Alt([Lit(ch) <span style="color: #00ffff;">for</span> ch <span style="color: #00ffff;">in</span> <span style="color: #00ff00;">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>])
<span style="color: #eedd82;">STRCHR</span> = Alt([Seq([Lit(ECHR), Alt([ Lit(ECHR), Lit(DQ) ])]),
              Alt([Lit(ch) <span style="color: #00ffff;">for</span> ch <span style="color: #00ffff;">in</span> <span style="color: #ff00ff; font-weight: bold;">map</span>(<span style="color: #ff00ff; font-weight: bold;">chr</span>, <span style="color: #ff00ff; font-weight: bold;">range</span>(32,127)) <span style="color: #00ffff;">if</span> ch <span style="color: #00ffff;">not</span> <span style="color: #00ffff;">in</span> <span style="color: #00ff00;">'"\\'</span>])])

<span style="color: #eedd82;">ebnf_sc</span> = Scanner([(ch, Lit(ch)) <span style="color: #00ffff;">for</span> ch <span style="color: #00ffff;">in</span> <span style="color: #00ff00;">"{([=|.])}"</span>]
                  + [(<span style="color: #00ff00;">'IDENT'</span>, Rep(LETTER)),
                     (<span style="color: #00ff00;">'STRING'</span>, Alt([Seq([Lit(DQ), Rep(STRCHR), Lit(DQ)])]))])
</pre>
</div>

<p>
Here's how to use it:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock25">&gt;&gt;&gt; ebnf_sc.scan(<span style="color: #00ff00;">'x = A | b'</span>)
[(<span style="color: #00ff00;">'x'</span>, <span style="color: #00ff00;">'IDENT'</span>, 0), (<span style="color: #00ff00;">'='</span>, <span style="color: #00ff00;">'='</span>, 2), (<span style="color: #00ff00;">'A'</span>, <span style="color: #00ff00;">'IDENT'</span>, 4), (<span style="color: #00ff00;">'|'</span>, <span style="color: #00ff00;">'|'</span>, 6), (<span style="color: #00ff00;">'b'</span>, <span style="color: #00ff00;">'IDENT'</span>, 8)]
</pre>
</div>
</div>
</div>


<div id="outline-container-orgheadline11" class="outline-2">
<h2 id="orgheadline11"><span class="section-number-2">11</span> <span class="todo TODO">TODO</span> -&#x2014; clean up below here ----</h2>
</div>
<div id="outline-container-orgheadline12" class="outline-2">
<h2 id="orgheadline12"><a id="nrogjy71jqg0"></a><span class="section-number-2">12</span> Strategy</h2>
<div class="outline-text-2" id="text-12">
<p>
The idea here is to manually construct a data structure (an abstract syntax tree) that describes a meta-grammar.
</p>

<p>
The meta-grammar describes whatever nice clean syntax we'd <i>like</i> to use for creating grammars in the future.
</p>

<p>
Building these trees by hand can get messy, though, so we'll stick with a simple syntax for this first round, and then use <i>that</i> to implement something better later.
</p>

<p>
Our first step is to define some types that we can use to tag the different parts of the tree. Each type represents the some feature of our pattern matching system.
</p>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13"><a id="9d0f2971jqg0"></a><span class="section-number-2">13</span> Manually build a base grammar to provide generic tokenization.</h2>
<div class="outline-text-2" id="text-13">
<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock26"><span style="color: #00ffff;">import</span> string
</pre>
</div>
<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock27"><span style="color: #eedd82;">base</span> = Gram(<span style="color: #00ff00;">'ebnf'</span>, [], <span style="color: #00ff00;">"rules common to all grammars"</span>, [
    Def(<span style="color: #00ff00;">'main'</span>, Orp(<span style="color: #00ff00;">'token'</span>)),
    Def(<span style="color: #00ff00;">'token'</span>,Seq([Skip(Orp(Ref(<span style="color: #00ff00;">'space'</span>))),
                  Alt([Ref(<span style="color: #00ff00;">'STRING'</span>), Ref(<span style="color: #00ff00;">'NUMBER'</span>),
                       Ref(<span style="color: #00ff00;">'IDENT'</span>), Ref(<span style="color: #00ff00;">'DELIM'</span>),
                       Rep(Not(Ref(<span style="color: #00ff00;">'space'</span>)))])])),
    Def(<span style="color: #00ff00;">'space'</span>, Orp(<span style="color: #00ff00;">'White'</span>)),
    <span style="color: #66f;"># </span><span style="color: #66f;">character classes:</span>
    Def(<span style="color: #00ff00;">'White'</span>, Alt([<span style="color: #ff00ff; font-weight: bold;">chr</span>(c) <span style="color: #00ffff;">for</span> c <span style="color: #00ffff;">in</span> <span style="color: #ff00ff; font-weight: bold;">range</span>(33)])),
    Def(<span style="color: #00ff00;">'Upper'</span>, Alt(<span style="color: #ff00ff; font-weight: bold;">list</span>(string.ascii_uppercase))),
    Def(<span style="color: #00ff00;">'Lower'</span>, Alt(<span style="color: #ff00ff; font-weight: bold;">list</span>(string.ascii_lowercase))),
    Def(<span style="color: #00ff00;">'Alpha'</span>, Alt([Ref(<span style="color: #00ff00;">'Lower'</span>), Ref(<span style="color: #00ff00;">'Upper'</span>)])),
    Def(<span style="color: #00ff00;">'Under'</span>, Lit(<span style="color: #00ff00;">'_'</span>)),
    Def(<span style="color: #00ff00;">'Neg'</span>, Lit(<span style="color: #00ff00;">'-'</span>)),
    Def(<span style="color: #00ff00;">'Digit'</span>, Alt([Lit(c) <span style="color: #00ffff;">for</span> c <span style="color: #00ffff;">in</span> string.digits])),
    Def(<span style="color: #00ff00;">'Hexit'</span>, Alt([Ref(<span style="color: #00ff00;">'Digit'</span>)]+[Lit(c) <span style="color: #00ffff;">for</span> c <span style="color: #00ffff;">in</span> <span style="color: #00ff00;">'abcdefABCDEF'</span>])),
    Def(<span style="color: #00ff00;">'Alnum'</span>, Alt([Ref(<span style="color: #00ff00;">'Under'</span>), Ref(<span style="color: #00ff00;">'Alpha'</span>), Ref(<span style="color: #00ff00;">'Digit'</span>)])),
    <span style="color: #66f;"># </span><span style="color: #66f;">simple patterns:</span>
    Def(<span style="color: #00ff00;">'IDENT'</span>, Seq([Alt([Ref(<span style="color: #00ff00;">'Under'</span>),Ref(<span style="color: #00ff00;">'Alpha'</span>)]), Orp(Ref(<span style="color: #00ff00;">'Alnum'</span>))])),
    Def(<span style="color: #00ff00;">'NUMBER'</span>,Seq([Opt(Ref(<span style="color: #00ff00;">'Neg'</span>)), Rep(Ref(<span style="color: #00ff00;">'Digit'</span>)),
                   Orp([Ref(<span style="color: #00ff00;">'Under'</span>),
                        Ref(<span style="color: #00ff00;">'Digit'</span>),Ref(<span style="color: #00ff00;">'Digit'</span>),Ref(<span style="color: #00ff00;">'Digit'</span>)])])),
    Def(<span style="color: #00ff00;">'STRING'</span>, Seq([Lit(DQ), Rep(Ref(<span style="color: #00ff00;">'STRCHR'</span>)), Lit(DQ)])),
    Def(<span style="color: #00ff00;">'STRCHR'</span>, Alt([Seq([Lit(ECHR), Alt([ Lit(ECHR), Lit(DQ) ])]),
                       Not(DQ) ])),
    Def(<span style="color: #00ff00;">'DELIM'</span>, Alt(<span style="color: #ff00ff; font-weight: bold;">list</span>(<span style="color: #00ff00;">'(){}[]'</span>))),
])
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14"><a id="7o9j7i21jqg0"></a><span class="section-number-2">14</span> Now define the bootstrap grammar to parse EBNF grammar definitions.</h2>
<div class="outline-text-2" id="text-14">
<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock28"><span style="color: #eedd82;">ebnf</span> = Gram(<span style="color: #00ff00;">'ebnf'</span>, [base], <span style="color: #00ff00;">"ebnf meta-grammar (for parsing grammars)"</span>, [
    Def(<span style="color: #00ff00;">'main'</span>, Orp(Ref(<span style="color: #00ff00;">'rule'</span>))),
    Def(<span style="color: #00ff00;">'rule'</span>, Seq([Var(<span style="color: #00ff00;">'name'</span>, Ref(<span style="color: #00ff00;">'IDENT'</span>)),
                     Lit(<span style="color: #00ff00;">'='</span>), Ref(<span style="color: #00ff00;">'expr'</span>), Lit(<span style="color: #00ff00;">'.'</span>) ])),
    Def(<span style="color: #00ff00;">'expr'</span>, Seq([ Ref(<span style="color: #00ff00;">'term'</span>), Orp([Lit(<span style="color: #00ff00;">'|'</span>), Ref(<span style="color: #00ff00;">'term'</span>) ]) ])),
    Def(<span style="color: #00ff00;">'term'</span>, Seq([ Ref(<span style="color: #00ff00;">'factor'</span>), Rep(Ref(<span style="color: #00ff00;">'factor'</span>)) ])),
    Def(<span style="color: #00ff00;">'factor'</span>, Alt([Ref(<span style="color: #00ff00;">'IDENT'</span>), Ref(<span style="color: #00ff00;">'STRING'</span>),
                       Ref(<span style="color: #00ff00;">'rep'</span>), Ref(<span style="color: #00ff00;">'opt'</span>), Ref(<span style="color: #00ff00;">'grp'</span>)])),
    Def(<span style="color: #00ff00;">'rep'</span>, Seq([Lit(<span style="color: #00ff00;">'{'</span>), New(Rep, Ref(<span style="color: #00ff00;">'expr'</span>)), Lit(<span style="color: #00ff00;">'}'</span>)])),  <span style="color: #66f;"># </span><span style="color: #66f;">'x*'</span>
    Def(<span style="color: #00ff00;">'opt'</span>, Seq([Lit(<span style="color: #00ff00;">'['</span>), New(Opt, Ref(<span style="color: #00ff00;">'expr'</span>)), Lit(<span style="color: #00ff00;">']'</span>)])),  <span style="color: #66f;"># </span><span style="color: #66f;">'x?'</span>
    Def(<span style="color: #00ff00;">'grp'</span>, Seq([Lit(<span style="color: #00ff00;">'('</span>), New(Grp, Ref(<span style="color: #00ff00;">'expr'</span>)), Lit(<span style="color: #00ff00;">')'</span>)])),  <span style="color: #66f;"># </span><span style="color: #66f;">'(x)'</span>
])
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-2">
<h2 id="orgheadline15"><a id="u8s6vh00kqg0"></a><span class="section-number-2">15</span> Worlds for backtracking.</h2>
<div class="outline-text-2" id="text-15">
<p>
A world is a context for holding changes, similar to a working copy in a version control system. The idea is that any time we might need to backtrack (any time an <code>Alt</code> node is encountered), we'll fork a new world, and changes we make are done to the world object. This way, if the match ultimately fails, we can rewind the side effects.
</p>

<p>
This ability is common in prototype-based langugaes like Self and JavaScript (though it isn't necessarily commonly <i>used</i>). The name 'World' and the idea of applying it to parsing comes from Alex Warth's <a href="http://www.tinlizzie.org/ometa/">OMeta</a> dissertation.
</p>

<p>
It's easy to make a python class that works this way: we just override <code>__getattr__</code> (for the <code>x.a</code> syntax), and <code>__getitem__</code> (for the <code>x[a]</code> syntax) so that they delegate to a prototype object when there's no local value defined.
</p>

<p>
Since we do <i>not</i> override the corresponding <code>__setitem__</code> and <code>__setattr__</code> methods, any assignment made to an attribute or item of the world will affect the local object, leaving the prototype's value unchanged.
</p>

<p>
It's very much like what happens when overriding methods in a subclass, except it happens for individual objects rather than classes, and it happens dynamically at runtime.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock29"><span style="color: #eedd82;">HOME</span> = {} <span style="color: #66f;"># </span><span style="color: #66f;">arbitrary dictionary object</span>

<span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">World</span>(<span style="color: #ff00ff; font-weight: bold;">dict</span>):

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__init__</span>(<span style="color: #00ffff;">self</span>, proto=HOME):
        <span style="color: #ff00ff; font-weight: bold;">super</span>(World, <span style="color: #00ffff;">self</span>).__init__()
        <span style="color: #00ffff;">self</span>.proto = proto

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__getattr__</span>(<span style="color: #00ffff;">self</span>, name):
        <span style="color: #66f;"># </span><span style="color: #66f;">called when attribute has no local definition.</span>
        <span style="color: #00ffff;">return</span> <span style="color: #ff00ff; font-weight: bold;">getattr</span>(<span style="color: #00ffff;">self</span>.proto, name)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__getitem__</span>(<span style="color: #00ffff;">self</span>, key):
        <span style="color: #00ffff;">if</span> key <span style="color: #00ffff;">in</span> <span style="color: #00ffff;">self</span>.keys(): <span style="color: #00ffff;">return</span> <span style="color: #ff00ff; font-weight: bold;">super</span>(World, <span style="color: #00ffff;">self</span>)[key]
        <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.proto[key]

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">changed</span>(<span style="color: #00ffff;">self</span>, key, val):
        <span style="color: #00ff00;">"""Forks a new world, with one key changed."""</span>
        <span style="color: #eedd82;">res</span> = World(<span style="color: #00ffff;">self</span>)
        <span style="color: #eedd82;">res</span>[key] = val
        <span style="color: #00ffff;">return</span> res
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-2">
<h2 id="orgheadline16"><a id="n0pcnnd1jqg0"></a><span class="section-number-2">16</span> Grammar Interpreter</h2>
<div class="outline-text-2" id="text-16">
<p>
We will assume for now that we have the entire string in memory.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock30"><span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Grin</span>(Dispatcher):
    <span style="color: #00ff00;">"""Grammar Interpreter"""</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__init__</span>(<span style="color: #00ffff;">self</span>, root):
        <span style="color: #ff00ff; font-weight: bold;">super</span>(Grin,<span style="color: #00ffff;">self</span>).__init__(root)
        <span style="color: #00ffff;">self</span>.init(root)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">parse</span>(<span style="color: #00ffff;">self</span>, src):
        <span style="color: #00ffff;">self</span>.env = World()
        <span style="color: #00ffff;">self</span>.src, <span style="color: #00ffff;">self</span>.pos, <span style="color: #00ffff;">self</span>.ch = src, 0, <span style="color: #00ff00;">''</span>
        <span style="color: #00ffff;">self</span>.page, <span style="color: #00ffff;">self</span>.line, <span style="color: #00ffff;">self</span>.col = 0, 0, 0

    &lt;&lt;@methods&gt;&gt;
</pre>
</div>
</div>
</div>


<div id="outline-container-orgheadline17" class="outline-2">
<h2 id="orgheadline17"><a id="npdbb4e1jqg0"></a><span class="section-number-2">17</span> OUTPUT wejalboot.py</h2>
<div class="outline-text-2" id="text-17">
<p>
And now we can put the whole thing together:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #00ff00;">"""</span>
<span style="color: #00ff00;">&gt;&gt;&gt; ebnf_sc.scan('x = A | b')</span>
<span style="color: #00ff00;">[('x', 'IDENT', 0), ('=', '=', 2), ('A', 'IDENT', 4), ('|', '|', 6), ('b', 'IDENT', 8)]</span>

<span style="color: #00ff00;">"""</span>
<span style="color: #00ffff;">from</span> collections <span style="color: #00ffff;">import</span> namedtuple
<span style="color: #00ffff;">from</span> warnings <span style="color: #00ffff;">import</span> warn
<span style="color: #00ffff;">import</span> string
<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">T</span>(tag, doc, args):
    <span style="color: #00ff00;">"""Creates a new tuple type."""</span>
    <span style="color: #eedd82;">res</span> = namedtuple(tag, args)
    <span style="color: #00ffff;">if</span> doc: res.<span style="color: #ff00ff; font-weight: bold;">__doc__</span>+=<span style="color: #00ff00;">' : '</span>+doc
    <span style="color: #00ffff;">return</span> res

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">TB</span>(tag, doc, args=[<span style="color: #00ff00;">'body'</span>]): <span style="color: #00ffff;">return</span> T(tag, doc, args)
<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">TI</span>(tag, doc, args=[<span style="color: #00ff00;">'item'</span>]): <span style="color: #00ffff;">return</span> T(tag, doc, args)
<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">TN</span>(tag, doc, args=[<span style="color: #00ff00;">'name'</span>]): <span style="color: #00ffff;">return</span> T(tag, doc, args)
<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">T2</span>(tag, doc, args=[<span style="color: #00ff00;">'name'</span>,<span style="color: #00ff00;">'body'</span>]): <span style="color: #00ffff;">return</span> T(tag, doc, args)

<span style="color: #eedd82;">Gram</span> = T(<span style="color: #00ff00;">'Gram'</span>, <span style="color: #00ff00;">'contains grammar rules (may inherit from `bases`).'</span>,
         [<span style="color: #00ff00;">'name'</span>, <span style="color: #00ff00;">'bases'</span>, <span style="color: #00ff00;">'doc'</span>, <span style="color: #00ff00;">'body'</span>])
<span style="color: #eedd82;">Def</span> = T(<span style="color: #00ff00;">'Def'</span>, <span style="color: #00ff00;">'define a named rule.'</span>, [<span style="color: #00ff00;">'name'</span>,<span style="color: #00ff00;">'body'</span>])
<span style="color: #eedd82;">Ref</span> = TN(<span style="color: #00ff00;">'Ref'</span>, <span style="color: #00ff00;">'refer to (invoke) a named rule'</span>)

<span style="color: #eedd82;">Any</span> = T(<span style="color: #00ff00;">'Any'</span>, <span style="color: #00ff00;">'match anything'</span>, [])
<span style="color: #eedd82;">Not</span> = TI(<span style="color: #00ff00;">'Not'</span>, <span style="color: #00ff00;">'fail if the pattern would match, but do not consume'</span>)
<span style="color: #eedd82;">Skip</span> = TI(<span style="color: #00ff00;">'Skip'</span>, <span style="color: #00ff00;">'match the pattern, but hide it from other rules'</span>)

<span style="color: #eedd82;">Emp</span> = T(<span style="color: #00ff00;">'Emp'</span>, <span style="color: #00ff00;">'empty pattern (always matches)'</span>, [])
<span style="color: #eedd82;">Emp</span> = Emp() <span style="color: #66f;"># </span><span style="color: #66f;">since it doesn't need arguments</span>

<span style="color: #eedd82;">Lit</span> = TI(<span style="color: #00ff00;">'Lit'</span>, <span style="color: #00ff00;">'match literal character (using ==)'</span>)
<span style="color: #eedd82;">Str</span> = TI(<span style="color: #00ff00;">'Str'</span>, <span style="color: #00ff00;">'match a string of literals'</span>)
<span style="color: #eedd82;">Seq</span> = TB(<span style="color: #00ff00;">'Seq'</span>, <span style="color: #00ff00;">'match a sequence of patterns'</span>)
<span style="color: #eedd82;">Grp</span> = TB(<span style="color: #00ff00;">'Grp'</span>, <span style="color: #00ff00;">'same as Seq, but renders in parentheses'</span>)
<span style="color: #eedd82;">Alt</span> = TB(<span style="color: #00ff00;">'Alt'</span>, <span style="color: #00ff00;">'match any of the alternatives'</span>)
<span style="color: #eedd82;">Rep</span> = TI(<span style="color: #00ff00;">'Rep'</span>, <span style="color: #00ff00;">'match 1 or more repetitions.'</span>)
<span style="color: #eedd82;">Opt</span> = TI(<span style="color: #00ff00;">'Opt'</span>, <span style="color: #00ff00;">'match 0 or 1 repetitions.'</span>)
<span style="color: #eedd82;">Orp</span> = TI(<span style="color: #00ff00;">'Orp'</span>, <span style="color: #00ff00;">'match 0 or more repetitions.'</span>)

<span style="color: #eedd82;">Var</span> = T2(<span style="color: #00ff00;">'Var'</span>, <span style="color: #00ff00;">'save matched string in a variable.'</span>)
<span style="color: #eedd82;">Val</span> = TN(<span style="color: #00ff00;">'Val'</span>, <span style="color: #00ff00;">'match against the saved value.'</span>)
<span style="color: #eedd82;">New</span> = T2(<span style="color: #00ff00;">'New'</span>, <span style="color: #00ff00;">'build a new class/tuple instance'</span>)
<span style="color: #eedd82;">Arg</span> = TB(<span style="color: #00ff00;">'Arg'</span>, <span style="color: #00ff00;">'pass matched data as arg to containing "New"'</span>)


<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">node_type</span>(node):
    <span style="color: #00ffff;">return</span> node.__class__.<span style="color: #ff00ff; font-weight: bold;">__name__</span>

<span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Dispatcher</span>:
    <span style="color: #00ff00;">"""Provides a simple generic dispatch mechanism based on method names"""</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">_find_handler</span>(<span style="color: #00ffff;">self</span>, prefix, node):
        <span style="color: #00ff00;">"""(prefix, namedtuple) -&gt; callable"""</span>
        <span style="color: #00ffff;">return</span> <span style="color: #ff00ff; font-weight: bold;">getattr</span>(<span style="color: #00ffff;">self</span>, <span style="color: #00ff00;">'_'</span>.join([prefix, node_type(node)]), <span style="color: #00ffff;">self</span>._unhandled)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">_unhandled</span>(<span style="color: #00ffff;">self</span>, node, *a, **kw):
        <span style="color: #00ff00;">"""Warn about unrecognized node types. (Just for development.)"""</span>
        <span style="color: #00ffff;">raise</span> <span style="color: #ff00ff;">ValueError</span>(<span style="color: #00ff00;">"no handler found for %s"</span> % node_type(node))

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">dispatch</span>(<span style="color: #00ffff;">self</span>, prefix, node, *a, **kw):
        <span style="color: #00ff00;">"""Find and invoke a handler for the given node."""</span>
        <span style="color: #eedd82;">h</span> = <span style="color: #00ffff;">self</span>._find_handler(prefix, node)
        <span style="color: #00ffff;">return</span> h(node, *a, **kw)


<span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Cursor</span>:

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__init__</span>(<span style="color: #00ffff;">self</span>, seq:[<span style="color: #ff00ff; font-weight: bold;">any</span>]):
        <span style="color: #00ffff;">self</span>.seq = seq    <span style="color: #66f;"># </span><span style="color: #66f;">sequence (probably a string)</span>
        <span style="color: #00ffff;">self</span>.val = <span style="color: #ffaf00;">None</span>   <span style="color: #66f;"># </span><span style="color: #66f;">current value</span>
        <span style="color: #00ffff;">self</span>.pos = -1     <span style="color: #66f;"># </span><span style="color: #66f;">current position</span>
        <span style="color: #00ffff;">self</span>.fwd()

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">fwd</span>(<span style="color: #00ffff;">self</span>)-&gt;<span style="color: #ff00ff; font-weight: bold;">any</span>:
        <span style="color: #00ff00;">"""Move forward in the sequence and return the next item."""</span>
        <span style="color: #eedd82;">end</span> = <span style="color: #ff00ff; font-weight: bold;">len</span>(<span style="color: #00ffff;">self</span>.seq)
        <span style="color: #00ffff;">self</span>.pos = <span style="color: #ff00ff; font-weight: bold;">min</span>(<span style="color: #00ffff;">self</span>.pos+1, end)
        <span style="color: #00ffff;">self</span>.val = <span style="color: #ffaf00;">None</span> <span style="color: #00ffff;">if</span> <span style="color: #00ffff;">self</span>.pos == end <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">self</span>.seq[<span style="color: #00ffff;">self</span>.pos] 
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">at_end</span>(<span style="color: #00ffff;">self</span>)-&gt;<span style="color: #ff00ff; font-weight: bold;">bool</span>:
        <span style="color: #00ff00;">"""Are we at the end of the sequence?"""</span>
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.val <span style="color: #00ffff;">is</span> <span style="color: #ffaf00;">None</span>


Match = namedtuple(<span style="color: #00ff00;">"Match"</span>, [<span style="color: #00ff00;">'txt'</span>, <span style="color: #00ff00;">'pos'</span>])
Match.<span style="color: #ff00ff; font-weight: bold;">__doc__</span> = <span style="color: #00ff00;">"Match Result"</span>

<span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Fail</span>:
    <span style="color: #00ff00;">"""Value to indicate failure."""</span>
    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__repr__</span>(<span style="color: #00ffff;">self</span>):
        <span style="color: #00ffff;">return</span> <span style="color: #00ff00;">"FAIL"</span>
FAIL = Fail()

<span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">M</span>(namedtuple(<span style="color: #00ff00;">"M"</span>, [<span style="color: #00ff00;">'val'</span>, <span style="color: #00ff00;">'cur'</span>, <span style="color: #00ff00;">'env'</span>])):
    <span style="color: #00ff00;">"""Internal Match State"""</span>

    <span style="color: #ff00ff;">@property</span>
    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">matched</span>(<span style="color: #00ffff;">self</span>):
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.val <span style="color: #00ffff;">is</span> <span style="color: #00ffff;">not</span> FAIL


<span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Matcher</span>(Dispatcher):
    <span style="color: #00ff00;">"""</span>
<span style="color: #00ff00;">    A simple matcher for regular languages.</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; m = Matcher(Alt([Lit("x"), Lit("y")])) # like re.compile("x|y")</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; m.match('xyz')                         # should match "x" at position 0</span>
<span style="color: #00ff00;">    Match(txt='x', pos=0)</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; m.match("zyx")                         # should fail to match</span>
<span style="color: #00ff00;">    FAIL</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; Matcher(Emp).match("hello")</span>
<span style="color: #00ff00;">    Match(txt='', pos=0)</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; m = Matcher(Seq([Lit("a"), Alt([Lit("a"), Lit("b")])]))</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; m.match("ab")</span>
<span style="color: #00ff00;">    Match(txt='ab', pos=0)</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; m.match("ac")</span>
<span style="color: #00ff00;">    FAIL</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; Matcher(Str("hello")).match("hello")</span>
<span style="color: #00ff00;">    Match(txt='hello', pos=0)</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; Matcher(Rep(Lit("a"))).match("aaabbbccc")</span>
<span style="color: #00ff00;">    Match(txt='aaa', pos=0)</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; m = Matcher(Opt(Lit("a")))</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; m.match("abc")</span>
<span style="color: #00ff00;">    Match(txt='a', pos=0)</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; m.match("xyz")</span>
<span style="color: #00ff00;">    Match(txt='', pos=0)</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; m = Matcher(Orp(Lit("a")))</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; m.match("aaabc")</span>
<span style="color: #00ff00;">    Match(txt='aaa', pos=0)</span>
<span style="color: #00ff00;">    &gt;&gt;&gt; m.match("xyz")</span>
<span style="color: #00ff00;">    Match(txt='', pos=0)</span>
<span style="color: #00ff00;">    """</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__init__</span>(<span style="color: #00ffff;">self</span>, node):
        <span style="color: #00ffff;">self</span>.root = node

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">_match</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ff00;">"""returns a match state tuple (the `M` class)"""</span>
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.dispatch(<span style="color: #00ff00;">'match'</span>, node, cur, env)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match</span>(<span style="color: #00ffff;">self</span>, s:<span style="color: #ff00ff; font-weight: bold;">str</span>):
        cur = Cursor(s)
        env = {}
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>._match(<span style="color: #00ffff;">self</span>.root, cur, env).val


<span style="color: #66f;"># </span><span style="color: #66f;">class Matcher:</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Lit</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">return</span> (M(Match(cur.val, cur.pos), cur.fwd(), env) <span style="color: #00ffff;">if</span> cur.val == node.item
                <span style="color: #00ffff;">else</span> M(FAIL, cur, env))

<span style="color: #66f;"># </span><span style="color: #66f;">class Matcher:</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Alt</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">for</span> item <span style="color: #00ffff;">in</span> node.body:
            m = <span style="color: #00ffff;">self</span>._match(item, cur, env)
            <span style="color: #00ffff;">if</span> m.matched: <span style="color: #00ffff;">return</span> m
        <span style="color: #00ffff;">return</span> m <span style="color: #66f;"># </span><span style="color: #66f;">last failure</span>


<span style="color: #66f;"># </span><span style="color: #66f;">class Matcher:</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Emp</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">return</span> M(Match(<span style="color: #00ff00;">""</span>, cur.pos), cur, env)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">_join</span>(<span style="color: #00ffff;">self</span>, matches):
        <span style="color: #00ff00;">"""helper to join match results for Seq and Str"""</span>
        <span style="color: #00ffff;">if</span> matches <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">return</span> FAIL
        <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> Match(<span style="color: #00ff00;">''</span>.join(v.txt <span style="color: #00ffff;">for</span> v <span style="color: #00ffff;">in</span> matches), matches[0].pos)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Seq</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        vals = []
        <span style="color: #00ffff;">for</span> item <span style="color: #00ffff;">in</span> node.body:
            res = <span style="color: #00ffff;">self</span>._match(item, cur, env)
            <span style="color: #00ffff;">if</span> res.val <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">return</span> M(FAIL, res.cur, env)
            <span style="color: #00ffff;">else</span>:
                <span style="color: #eedd82;">val</span>, <span style="color: #eedd82;">cur</span>, env = res
                vals.append(val)
        <span style="color: #00ffff;">return</span> M(<span style="color: #00ffff;">self</span>._join(vals), res.cur, env)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Str</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>._match(Seq([Lit(c) <span style="color: #00ffff;">for</span> c <span style="color: #00ffff;">in</span> node.item]), cur, env)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Rep</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        vals = []
        <span style="color: #00ffff;">while</span> <span style="color: #ffaf00;">True</span>:
            res = <span style="color: #00ffff;">self</span>._match(node.item, cur, env)
            <span style="color: #00ffff;">if</span> res.val <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">break</span>
            <span style="color: #00ffff;">else</span>:
                <span style="color: #eedd82;">val</span>, <span style="color: #eedd82;">cur</span>, env = res
                vals.append(val)
        <span style="color: #00ffff;">return</span> M(<span style="color: #00ffff;">self</span>._join(vals <span style="color: #00ffff;">or</span> FAIL), cur, env)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Opt</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>._match(Alt([node.item, Emp]), cur, env)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Orp</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>._match(Opt(Rep(node.item)), cur, env)


<span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Scanner</span>:

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__init__</span>(<span style="color: #00ffff;">self</span>, rules: [(<span style="color: #ff00ff; font-weight: bold;">str</span>, namedtuple)]):
        <span style="color: #00ffff;">self</span>.order = [rule[0] <span style="color: #00ffff;">for</span> rule <span style="color: #00ffff;">in</span> rules]  <span style="color: #66f;"># </span><span style="color: #66f;">test rules in given order</span>
        <span style="color: #00ffff;">self</span>.rules = <span style="color: #ff00ff; font-weight: bold;">dict</span>(rules)
        <span style="color: #66f;"># </span><span style="color: #66f;">default whitespace handler:</span>
        <span style="color: #00ffff;">if</span> <span style="color: #00ff00;">'_'</span> <span style="color: #00ffff;">not</span> <span style="color: #00ffff;">in</span> rules:
            <span style="color: #00ffff;">self</span>.order.insert(0, <span style="color: #00ff00;">'_'</span>)
            <span style="color: #00ffff;">self</span>.rules[<span style="color: #00ff00;">'_'</span>] = Alt([Lit(<span style="color: #ff00ff; font-weight: bold;">chr</span>(i)) <span style="color: #00ffff;">for</span> i <span style="color: #00ffff;">in</span> <span style="color: #ff00ff; font-weight: bold;">range</span>(33)])

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">gen_tokens</span>(<span style="color: #00ffff;">self</span>, txt):
        cur = Cursor(txt)
        env = {}
        matcher = Matcher(Emp)
        <span style="color: #00ffff;">while</span> <span style="color: #00ffff;">not</span> cur.at_end():
            <span style="color: #00ffff;">for</span> rule <span style="color: #00ffff;">in</span> <span style="color: #00ffff;">self</span>.order:
                m = matcher._match(<span style="color: #00ffff;">self</span>.rules[rule], cur, env)
                <span style="color: #00ffff;">if</span> m.matched:
                    <span style="color: #eedd82;">match</span>, <span style="color: #eedd82;">cur</span>, env = m
                    <span style="color: #00ffff;">if</span> rule != <span style="color: #00ff00;">'_'</span>:
                        <span style="color: #00ffff;">yield</span> (match.txt, rule, match.pos)
                    <span style="color: #00ffff;">break</span>
                <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">continue</span>
            <span style="color: #00ffff;">else</span>:
                <span style="color: #00ffff;">raise</span> <span style="color: #ff00ff;">ValueError</span>(<span style="color: #00ff00;">"unrecognized character at position %i : '%s'"</span>
                                 % (cur.pos, cur.val))

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">scan</span>(<span style="color: #00ffff;">self</span>, txt):
        <span style="color: #00ffff;">return</span> <span style="color: #ff00ff; font-weight: bold;">list</span>(<span style="color: #00ffff;">self</span>.gen_tokens(txt))

ebnf_src = <span style="color: #00ff00;">'''\</span>
<span style="color: #00ff00;">main = { rule } .</span>
<span style="color: #00ff00;">rule = IDENT "=" expr "." .</span>
<span style="color: #00ff00;">expr = term { "|" term } .</span>
<span style="color: #00ff00;">term = factor { factor } .</span>
<span style="color: #00ff00;">factor = IDENT | STRING | "{" expr "}" | "[" expr "]" | "(" expr ")" .</span>
<span style="color: #00ff00;">'''</span>

<span style="color: #eedd82;">ECHR</span>, <span style="color: #eedd82;">SQ</span>, DQ = [<span style="color: #00ff00;">'\\'</span>, <span style="color: #00ff00;">"'"</span>, <span style="color: #00ff00;">'"'</span>]
LETTER = Alt([Lit(ch) <span style="color: #00ffff;">for</span> ch <span style="color: #00ffff;">in</span> <span style="color: #00ff00;">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>])
STRCHR = Alt([Seq([Lit(ECHR), Alt([ Lit(ECHR), Lit(DQ) ])]),
              Alt([Lit(ch) <span style="color: #00ffff;">for</span> ch <span style="color: #00ffff;">in</span> <span style="color: #ff00ff; font-weight: bold;">map</span>(<span style="color: #ff00ff; font-weight: bold;">chr</span>, <span style="color: #ff00ff; font-weight: bold;">range</span>(32,127)) <span style="color: #00ffff;">if</span> ch <span style="color: #00ffff;">not</span> <span style="color: #00ffff;">in</span> <span style="color: #00ff00;">'"\\'</span>])])

ebnf_sc = Scanner([(ch, Lit(ch)) <span style="color: #00ffff;">for</span> ch <span style="color: #00ffff;">in</span> <span style="color: #00ff00;">"{([=|.])}"</span>]
                  + [(<span style="color: #00ff00;">'IDENT'</span>, Rep(LETTER)),
                     (<span style="color: #00ff00;">'STRING'</span>, Alt([Seq([Lit(DQ), Rep(STRCHR), Lit(DQ)])]))])

base = Gram(<span style="color: #00ff00;">'ebnf'</span>, [], <span style="color: #00ff00;">"rules common to all grammars"</span>, [
    Def(<span style="color: #00ff00;">'main'</span>, Orp(<span style="color: #00ff00;">'token'</span>)),
    Def(<span style="color: #00ff00;">'token'</span>,Seq([Skip(Orp(Ref(<span style="color: #00ff00;">'space'</span>))),
                  Alt([Ref(<span style="color: #00ff00;">'STRING'</span>), Ref(<span style="color: #00ff00;">'NUMBER'</span>),
                       Ref(<span style="color: #00ff00;">'IDENT'</span>), Ref(<span style="color: #00ff00;">'DELIM'</span>),
                       Rep(Not(Ref(<span style="color: #00ff00;">'space'</span>)))])])),
    Def(<span style="color: #00ff00;">'space'</span>, Orp(<span style="color: #00ff00;">'White'</span>)),
    <span style="color: #66f;"># </span><span style="color: #66f;">character classes:</span>
    Def(<span style="color: #00ff00;">'White'</span>, Alt([<span style="color: #ff00ff; font-weight: bold;">chr</span>(c) <span style="color: #00ffff;">for</span> c <span style="color: #00ffff;">in</span> <span style="color: #ff00ff; font-weight: bold;">range</span>(33)])),
    Def(<span style="color: #00ff00;">'Upper'</span>, Alt(<span style="color: #ff00ff; font-weight: bold;">list</span>(string.ascii_uppercase))),
    Def(<span style="color: #00ff00;">'Lower'</span>, Alt(<span style="color: #ff00ff; font-weight: bold;">list</span>(string.ascii_lowercase))),
    Def(<span style="color: #00ff00;">'Alpha'</span>, Alt([Ref(<span style="color: #00ff00;">'Lower'</span>), Ref(<span style="color: #00ff00;">'Upper'</span>)])),
    Def(<span style="color: #00ff00;">'Under'</span>, Lit(<span style="color: #00ff00;">'_'</span>)),
    Def(<span style="color: #00ff00;">'Neg'</span>, Lit(<span style="color: #00ff00;">'-'</span>)),
    Def(<span style="color: #00ff00;">'Digit'</span>, Alt([Lit(c) <span style="color: #00ffff;">for</span> c <span style="color: #00ffff;">in</span> string.digits])),
    Def(<span style="color: #00ff00;">'Hexit'</span>, Alt([Ref(<span style="color: #00ff00;">'Digit'</span>)]+[Lit(c) <span style="color: #00ffff;">for</span> c <span style="color: #00ffff;">in</span> <span style="color: #00ff00;">'abcdefABCDEF'</span>])),
    Def(<span style="color: #00ff00;">'Alnum'</span>, Alt([Ref(<span style="color: #00ff00;">'Under'</span>), Ref(<span style="color: #00ff00;">'Alpha'</span>), Ref(<span style="color: #00ff00;">'Digit'</span>)])),
    <span style="color: #66f;"># </span><span style="color: #66f;">simple patterns:</span>
    Def(<span style="color: #00ff00;">'IDENT'</span>, Seq([Alt([Ref(<span style="color: #00ff00;">'Under'</span>),Ref(<span style="color: #00ff00;">'Alpha'</span>)]), Orp(Ref(<span style="color: #00ff00;">'Alnum'</span>))])),
    Def(<span style="color: #00ff00;">'NUMBER'</span>,Seq([Opt(Ref(<span style="color: #00ff00;">'Neg'</span>)), Rep(Ref(<span style="color: #00ff00;">'Digit'</span>)),
                   Orp([Ref(<span style="color: #00ff00;">'Under'</span>),
                        Ref(<span style="color: #00ff00;">'Digit'</span>),Ref(<span style="color: #00ff00;">'Digit'</span>),Ref(<span style="color: #00ff00;">'Digit'</span>)])])),
    Def(<span style="color: #00ff00;">'STRING'</span>, Seq([Lit(DQ), Rep(Ref(<span style="color: #00ff00;">'STRCHR'</span>)), Lit(DQ)])),
    Def(<span style="color: #00ff00;">'STRCHR'</span>, Alt([Seq([Lit(ECHR), Alt([ Lit(ECHR), Lit(DQ) ])]),
                       Not(DQ) ])),
    Def(<span style="color: #00ff00;">'DELIM'</span>, Alt(<span style="color: #ff00ff; font-weight: bold;">list</span>(<span style="color: #00ff00;">'(){}[]'</span>))),
])
ebnf = Gram(<span style="color: #00ff00;">'ebnf'</span>, [base], <span style="color: #00ff00;">"ebnf meta-grammar (for parsing grammars)"</span>, [
    Def(<span style="color: #00ff00;">'main'</span>, Orp(Ref(<span style="color: #00ff00;">'rule'</span>))),
    Def(<span style="color: #00ff00;">'rule'</span>, Seq([Var(<span style="color: #00ff00;">'name'</span>, Ref(<span style="color: #00ff00;">'IDENT'</span>)),
                     Lit(<span style="color: #00ff00;">'='</span>), Ref(<span style="color: #00ff00;">'expr'</span>), Lit(<span style="color: #00ff00;">'.'</span>) ])),
    Def(<span style="color: #00ff00;">'expr'</span>, Seq([ Ref(<span style="color: #00ff00;">'term'</span>), Orp([Lit(<span style="color: #00ff00;">'|'</span>), Ref(<span style="color: #00ff00;">'term'</span>) ]) ])),
    Def(<span style="color: #00ff00;">'term'</span>, Seq([ Ref(<span style="color: #00ff00;">'factor'</span>), Rep(Ref(<span style="color: #00ff00;">'factor'</span>)) ])),
    Def(<span style="color: #00ff00;">'factor'</span>, Alt([Ref(<span style="color: #00ff00;">'IDENT'</span>), Ref(<span style="color: #00ff00;">'STRING'</span>),
                       Ref(<span style="color: #00ff00;">'rep'</span>), Ref(<span style="color: #00ff00;">'opt'</span>), Ref(<span style="color: #00ff00;">'grp'</span>)])),
    Def(<span style="color: #00ff00;">'rep'</span>, Seq([Lit(<span style="color: #00ff00;">'{'</span>), New(Rep, Ref(<span style="color: #00ff00;">'expr'</span>)), Lit(<span style="color: #00ff00;">'}'</span>)])),  <span style="color: #66f;"># </span><span style="color: #66f;">'x*'</span>
    Def(<span style="color: #00ff00;">'opt'</span>, Seq([Lit(<span style="color: #00ff00;">'['</span>), New(Opt, Ref(<span style="color: #00ff00;">'expr'</span>)), Lit(<span style="color: #00ff00;">']'</span>)])),  <span style="color: #66f;"># </span><span style="color: #66f;">'x?'</span>
    Def(<span style="color: #00ff00;">'grp'</span>, Seq([Lit(<span style="color: #00ff00;">'('</span>), New(Grp, Ref(<span style="color: #00ff00;">'expr'</span>)), Lit(<span style="color: #00ff00;">')'</span>)])),  <span style="color: #66f;"># </span><span style="color: #66f;">'(x)'</span>
])

HOME = {} <span style="color: #66f;"># </span><span style="color: #66f;">arbitrary dictionary object</span>

<span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">World</span>(<span style="color: #ff00ff; font-weight: bold;">dict</span>):

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__init__</span>(<span style="color: #00ffff;">self</span>, proto=HOME):
        <span style="color: #ff00ff; font-weight: bold;">super</span>(World, <span style="color: #00ffff;">self</span>).__init__()
        <span style="color: #00ffff;">self</span>.proto = proto

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__getattr__</span>(<span style="color: #00ffff;">self</span>, name):
        <span style="color: #66f;"># </span><span style="color: #66f;">called when attribute has no local definition.</span>
        <span style="color: #00ffff;">return</span> <span style="color: #ff00ff; font-weight: bold;">getattr</span>(<span style="color: #00ffff;">self</span>.proto, name)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__getitem__</span>(<span style="color: #00ffff;">self</span>, key):
        <span style="color: #00ffff;">if</span> key <span style="color: #00ffff;">in</span> <span style="color: #00ffff;">self</span>.keys(): <span style="color: #00ffff;">return</span> <span style="color: #ff00ff; font-weight: bold;">super</span>(World, <span style="color: #00ffff;">self</span>)[key]
        <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.proto[key]

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">changed</span>(<span style="color: #00ffff;">self</span>, key, val):
        <span style="color: #00ff00;">"""Forks a new world, with one key changed."""</span>
        res = World(<span style="color: #00ffff;">self</span>)
        res[key] = val
        <span style="color: #00ffff;">return</span> res


<span style="color: #00ffff;">class</span> <span style="color: #ff00ff;">Grin</span>(Dispatcher):
    <span style="color: #00ff00;">"""Grammar Interpreter"""</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">__init__</span>(<span style="color: #00ffff;">self</span>, root):
        <span style="color: #ff00ff; font-weight: bold;">super</span>(Grin,<span style="color: #00ffff;">self</span>).__init__(root)
        <span style="color: #00ffff;">self</span>.init(root)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">parse</span>(<span style="color: #00ffff;">self</span>, src):
        <span style="color: #00ffff;">self</span>.env = World()
        <span style="color: #00ffff;">self</span>.src, <span style="color: #00ffff;">self</span>.pos, <span style="color: #00ffff;">self</span>.ch = src, 0, <span style="color: #00ff00;">''</span>
        <span style="color: #00ffff;">self</span>.page, <span style="color: #00ffff;">self</span>.line, <span style="color: #00ffff;">self</span>.col = 0, 0, 0


    <span style="color: #66f;"># </span><span style="color: #66f;">(inside  `class Grin`...)</span>

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Ref</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #66f;"># </span><span style="color: #66f;">pass in fresh World, then discard changes</span>
        res = <span style="color: #00ffff;">self</span>.match(<span style="color: #00ffff;">self</span>.defs[node.name], cur, World())
        <span style="color: #00ffff;">if</span> res.val <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">return</span> (FAIL, env)
        <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> (res.val, res[1], env)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Not</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        res = <span style="color: #00ffff;">self</span>.match(node.item, cur, env)
        <span style="color: #00ffff;">if</span> res.val <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">return</span> (<span style="color: #ffaf00;">None</span>, cur, res[1])
        <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> (FAIL, res[1])

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Var</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        res = <span style="color: #00ffff;">self</span>.match(node.item, cur, env)
        <span style="color: #00ffff;">if</span> res.val <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">return</span> res
        <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> (res.val, cur, env.changed(node.name, res.val))

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Act</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">raise</span> <span style="color: #ff00ff;">NotImplementedError</span>(<span style="color: #00ff00;">'no semantic actions yet.'</span>)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Box</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
        <span style="color: #00ffff;">raise</span> <span style="color: #ff00ff;">NotImplementedError</span>(<span style="color: #00ff00;">'no tree matching yet.'</span>)


    <span style="color: #66f;"># </span><span style="color: #66f;">(still inside  `class Grin`...)</span>
    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">init</span>(<span style="color: #00ffff;">self</span>, node):
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.dispatch(<span style="color: #00ff00;">'init'</span>, node)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">init_Gram</span>(<span style="color: #00ffff;">self</span>, node):
        <span style="color: #00ffff;">self</span>.defs = {}
        <span style="color: #00ffff;">for</span> child <span style="color: #00ffff;">in</span> node.body: <span style="color: #00ffff;">self</span>.init(child)

    <span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">init_Def</span>(<span style="color: #00ffff;">self</span>, node):
        <span style="color: #00ffff;">self</span>.defs[node.name] = node

<span style="color: #00ffff;">if</span> <span style="color: #ff00ff; font-weight: bold;">__name__</span>==<span style="color: #00ff00;">"__main__"</span>:
    <span style="color: #00ffff;">print</span>(Grin(ebnf).parse(ebnf_src))
</pre>
</div>

<p>
If we try to run this now, here's what we'll get:
</p>

<div class="org-src-container">

<pre class="src src-org"><span style="color: color-208;">wejalboot.py:92:</span> <span style="font-weight: bold;">UserWarning: no handler for init</span><span style="color: brightyellow; background-color: color-17; font-weight: bold;">_Gram</span>
  <span style="color: #00ff00;">yield warn('no handler for tag: %s' % node.__class__.__name__)</span>
<span style="color: #ffd700; font-style: italic;">None</span>
</pre>
</div>

<p>
So now our job is to go back and fill in a handler method for each node until it's able to walk the whole tree.
</p>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-2">
<h2 id="orgheadline18"><a id="yg99mk91oqg0"></a><span class="section-number-2">18</span> Inference Rules</h2>
<div class="outline-text-2" id="text-18">
<p>
These were translated from the sequent notation in Warth's Ometa paper.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock31"><span style="color: #66f;"># </span><span style="color: #66f;">(inside  `class Grin`...)</span>

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Ref</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #66f;"># </span><span style="color: #66f;">pass in fresh World, then discard changes</span>
    <span style="color: #eedd82;">res</span> = <span style="color: #00ffff;">self</span>.match(<span style="color: #00ffff;">self</span>.defs[node.name], cur, World())
    <span style="color: #00ffff;">if</span> res.val <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">return</span> (FAIL, env)
    <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> (res.val, res[1], env)

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Not</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #eedd82;">res</span> = <span style="color: #00ffff;">self</span>.match(node.item, cur, env)
    <span style="color: #00ffff;">if</span> res.val <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">return</span> (<span style="color: #ffaf00;">None</span>, cur, res[1])
    <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> (FAIL, res[1])

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Var</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #eedd82;">res</span> = <span style="color: #00ffff;">self</span>.match(node.item, cur, env)
    <span style="color: #00ffff;">if</span> res.val <span style="color: #00ffff;">is</span> FAIL: <span style="color: #00ffff;">return</span> res
    <span style="color: #00ffff;">else</span>: <span style="color: #00ffff;">return</span> (res.val, cur, env.changed(node.name, res.val))

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Act</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #00ffff;">raise</span> <span style="color: #ff00ff;">NotImplementedError</span>(<span style="color: #00ff00;">'no semantic actions yet.'</span>)

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">match_Box</span>(<span style="color: #00ffff;">self</span>, node, cur, env):
    <span style="color: #00ffff;">raise</span> <span style="color: #ff00ff;">NotImplementedError</span>(<span style="color: #00ff00;">'no tree matching yet.'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline19" class="outline-2">
<h2 id="orgheadline19"><a id="ks01bt30kqg0"></a><span class="section-number-2">19</span> Compilation step.</h2>
<div class="outline-text-2" id="text-19">
<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock32"><span style="color: #66f;"># </span><span style="color: #66f;">(still inside  `class Grin`...)</span>
<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">init</span>(<span style="color: #00ffff;">self</span>, node):
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">self</span>.dispatch(<span style="color: #00ff00;">'init'</span>, node)

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">init_Gram</span>(<span style="color: #00ffff;">self</span>, node):
    <span style="color: #00ffff;">self</span>.defs = {}
    <span style="color: #00ffff;">for</span> child <span style="color: #00ffff;">in</span> node.body: <span style="color: #00ffff;">self</span>.init(child)

<span style="color: #00ffff;">def</span> <span style="color: #ffffff; font-weight: bold;">init_Def</span>(<span style="color: #00ffff;">self</span>, node):
    <span style="color: #00ffff;">self</span>.defs[node.name] = node
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-2">
<h2 id="orgheadline20"><a id="hnv0l310pqg0"></a><span class="section-number-2">20</span> <span class="todo TODO">TODO</span> credits</h2>
<div class="outline-text-2" id="text-20">
<ul class="org-ul">
<li>grammar rules (and the 'world' concept) are adapted from Alessandro Warth's <a href="http://tinlizzie.org/ometa/">Ometa</a> system.</li>
</ul>
</div>
</div>
</div>
</body>
</html>
