<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-04-15 Fri 14:48 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>wejal bootstrap</title>
<meta  name="generator" content="Org-mode" />
<link rel="stylesheet" type="text/css" href="/etc/style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">wejal bootstrap</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. A Grammar Interpreter</a></li>
<li><a href="#orgheadline2">2. Grammar Combinators</a></li>
<li><a href="#orgheadline3">3. Generic dispatch</a></li>
<li><a href="#orgheadline4">4. Input cursor</a></li>
<li><a href="#orgheadline5">5. Data structure for parse results.</a></li>
<li><a href="#orgheadline6">6. Simple pattern matching.</a></li>
<li><a href="#orgheadline7">7. <span class="todo nilTODO">TODO</span> -&#x2014; finish cleaning up everything after this point ---</a></li>
<li><a href="#orgheadline8">8. Strategy</a></li>
<li><a href="#orgheadline9">9. Manually build a base grammar to provide generic tokenization.</a></li>
<li><a href="#orgheadline10">10. Now define the bootstrap grammar to parse EBNF grammar definitions.</a></li>
<li><a href="#orgheadline11">11. Worlds for backtracking.</a></li>
<li><a href="#orgheadline12">12. Grammar Interpreter</a></li>
<li><a href="#orgheadline13">13. ebnf in ebnf</a></li>
<li><a href="#orgheadline14">14. OUTPUT wejalboot.py</a></li>
<li><a href="#orgheadline15">15. Inference Rules</a></li>
<li><a href="#orgheadline16">16. Compilation step.</a></li>
<li><a href="#orgheadline17">17. <span class="todo nilTODO">TODO</span> credits</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><a id="7zli6i3147h0"></a><span class="section-number-2">1</span> A Grammar Interpreter</h2>
<div class="outline-text-2" id="text-1">
<p>
Our goal is to bootstrap an interpreter for a new programming language.
We would like to build it incrementally from the ground up.
</p>

<p>
Rather than writing a parser by hand, we would like to model the language syntax and semantics as data, and pass this data to a generic <i>grammar interpreter</i>.
</p>

<p>
We will build the grammar interpreter incrementally, with test cases.
</p>

<p>
For starters, we will focus on simple regular expressions:, much like python's built-in <code>re</code> module.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock1">&gt;&gt;&gt; m = Matcher(Alt([Lit("x"), Lit("y"))   # match the letter x or y, like re.compile("x|y")
&gt;&gt;&gt; m.match("xyz")                         # should match "x" at position 0 
Match(txt="x", pos=0)
&gt;&gt;&gt; m.match("zyx")                         # should fail to match
FAIL
</pre>
</div>

<p>
Obviously, the nice syntax provided by the <code>re</code> module is nicer than building pattern structures by hand. We will address this soon by bootstrapping our own parser for patterns. In the meantime, we will build our rule definitions by building data structures with python's <code>namedtuple</code>.
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><a id="9906u111jqg0"></a><span class="section-number-2">2</span> Grammar Combinators</h2>
<div class="outline-text-2" id="text-2">
<p>
Here are our data types for modeling grammar definitions. Since we are using <code>namedtuple</code>, there is no actual behavior associated with them. They're just constructors we can manually compose to create data structures.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock2">from collections import namedtuple
</pre>
</div>
<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock3">def T(tag, doc, args):
    """Creates a new tuple type."""
    res = namedtuple(tag, args)
    if doc: res.__doc__+=' : '+doc
    return res

def TB(tag, doc, args=['body']): return T(tag, doc, args)
def TI(tag, doc, args=['item']): return T(tag, doc, args)
def TN(tag, doc, args=['name']): return T(tag, doc, args)
def T2(tag, doc, args=['name','body']): return T(tag, doc, args)

Gram = T('Gram', 'contains grammar rules (may inherit from `base`).',
         ['name', 'base', 'doc', 'body'])
Def = T('Def', 'define a named rule.', ['name','body'])
Ref = TN('Ref', 'refer to (invoke) a named rule')

Any = T('Any', 'match anything', [])
Not = TI('Not', 'fail if the pattern would match, but do not consume')
Skip = TI('Skip', 'match the pattern, but hide it from other rules')

Lit = TI('Lit', 'match literal item (using ==)')
Seq = TB('Seq', 'match a sequence of patterns')
Grp = TB('Grp', 'same as Seq, but renders in parentheses')
Alt = TB('Alt', 'match any of the alternatives')
Rep = TI('Rep', 'match 1 or more repetitions.')
Opt = TI('Opt', 'match 0 or 1 repetitions.')
Orp = TI('Orp', 'match 0 or more repetitions.')

Var = T2('Var', 'save matched string in a variable.')
Val = TN('Val', 'match against the saved value.')
New = T2('New', 'build a new class/tuple instance')
Arg = TB('Arg', 'pass matched data as arg to containing "New"')
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3"><a id="w0bhd8b1jqg0"></a><span class="section-number-2">3</span> Generic dispatch</h2>
<div class="outline-text-2" id="text-3">
<p>
Since we will be composing instances of these types into trees, and want our system to interpret the types differently, we need a way to map each type to an appropriate handler.
</p>

<p>
We will imlement this using a base class that simply maps each <code>namedtuple</code> type to a method with the same name (and a given prefix).
</p>

<p>
In other words, when we see an <code>Alt</code> node in the tree, we can use this to automatically invoke a method in our interpreter class called <code>match_Alt</code>.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock4">from warnings import warn
</pre>
</div>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock5">def node_type(node):
    return node.__class__.__name__

class Dispatcher(object):
    """Provides a simple generic dispatch mechanism based on method names"""

    def _find_handler(self, prefix, node):
        """(prefix, namedtuple) -&gt; callable"""
        return getattr(self, '_'.join([prefix, node_type(node)]), self._unhandled)

    def _unhandled(self, node, *a, **kw):
        """Warn about unrecognized node types. (Just for development.)"""
        raise ValueError("no handler found for %s" % node_type(node))

    def dispatch(self, prefix, node, *a, **kw):
        """Find and invoke a handler for the given node."""
        h = self._find_handler(prefix, node)
        return h(node, *a, **kw)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4"><a id="m3udu291oqg0"></a><span class="section-number-2">4</span> Input cursor</h2>
<div class="outline-text-2" id="text-4">
<p>
We also need to keep track of where we are in the input sequence.
The following helper class will do the work for us:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock6">class Cursor(object):

    def __init__(self, seq:[any]):
        self.seq = seq    # sequence (probably a string)
        self.val = None   # current value
        self.pos = -1     # current position
        self.fwd()

    def fwd(self)-&gt;any:
        """Move forward in the sequence and return the next item."""
        end = len(self.seq)
        self.pos = min(self.pos+1, end)
        self.val = None if self.pos == end else self.seq[self.pos] 
        return self
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5"><a id="x88gff91oqg0"></a><span class="section-number-2">5</span> Data structure for parse results.</h2>
<div class="outline-text-2" id="text-5">
<p>
Matching should either produce:
</p>

<p>
&#x2026; A match object, which stores the matched text, and its position within the input:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock7">Match = namedtuple("Match", ['txt', 'pos'])
Match.__doc__ = "Match Result"
</pre>
</div>

<p>
&#x2026; Or, a special constant called <code>FAIL</code>:
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock8">class Fail(object):
    """Value to indicate failure."""
    def __repr__(self):
        return "FAIL"
FAIL = Fail()
</pre>
</div>

<p>
We are also going to use a namedtuple to represent the match state at any given time.
This state includes the match result, a cursor marking the position in the string, and an environment (which we will use later on for storing state). 
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock9">class M(namedtuple("M", ['val', 'cur', 'env'])):
    """Internal Match State"""

    @property
    def matched(self):
        return self.val is not FAIL
</pre>
</div>
</div>
</div>


<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6"><a id="yba9ij4147h0"></a><span class="section-number-2">6</span> Simple pattern matching.</h2>
<div class="outline-text-2" id="text-6">
<p>
Now we can start building the matcher. First we will set up the <code>Dispatch</code> stuff:  
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock10">class Matcher(Dispatcher):
    """A simple matcher for regular languages."""

    def __init__(self, node):
        self.root = node

    def _match(self, node, cur, env):
        """returns a match state tuple (the `M` class)"""
        return self.dispatch('match', node, cur, env)

    def match(self, s:str):
        cur = Cursor(s)
        env = {}
        return self._match(self.root, cur, env).val
</pre>
</div>

<p>
Now we are ready to implement the handlers for our initial example:
</p>

<p>
The simplest case is comparison against a single literal character (<code>Lit</code>):
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock11"># class Matcher:

    def match_Lit(self, node, cur, env):
        return (M(Match(cur.val, cur.pos), cur.fwd(), env) if cur.val == node.item
                else M(FAIL, cur, env))
</pre>
</div>


<p>
For <code>Alt</code>, we just try matching each alternative, in sequence.
</p>

<p>
Note that only the <i>first</i> matching pattern is returned.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock12"># class Matcher:

    def match_Alt(self, node, cur, env):
        for item in node.body:
            m = self._match(item, cur, env)
            if m.matched: return m
        return m # last failure
</pre>
</div>

<p>
At this point, our original example using <code>Alt([ Lit('x'), Lit('y') ])</code> works as advertised.
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7"><a id="9u58i7e147h0"></a><span class="section-number-2">7</span> <span class="todo TODO">TODO</span> -&#x2014; finish cleaning up everything after this point ---</h2>
<div class="outline-text-2" id="text-7">
<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock13"># class Matcher:

    def match_Seq(self, node):
        pass

    def match_Rep(self, node):
        pass

    def match_Opt(self, node):
        pass

    def match_Orp(self, node):
        pass
</pre>
</div>
</div>
</div>





<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8"><a id="nrogjy71jqg0"></a><span class="section-number-2">8</span> Strategy</h2>
<div class="outline-text-2" id="text-8">
<p>
The idea here is to manually construct a data structure (an abstract syntax tree) that describes a meta-grammar.
</p>

<p>
The meta-grammar describes whatever nice clean syntax we'd <i>like</i> to use for creating grammars in the future.
</p>

<p>
Building these trees by hand can get messy, though, so we'll stick with a simple syntax for this first round, and then use <i>that</i> to implement something better later.
</p>

<p>
Our first step is to define some types that we can use to tag the different parts of the tree. Each type represents the some feature of our pattern matching system.
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-2">
<h2 id="orgheadline9"><a id="9d0f2971jqg0"></a><span class="section-number-2">9</span> Manually build a base grammar to provide generic tokenization.</h2>
<div class="outline-text-2" id="text-9">
<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock14">import string
</pre>
</div>
<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock15">ECHR, SQ, DQ = ['\\', "'", '"']
base = Gram('ebnf', [], "rules common to all grammars", [
    Def('main', Orp('token')),
    Def('token',Seq([Skip(Orp(Ref('space'))),
                  Alt([Ref('STRING'), Ref('NUMBER'),
                       Ref('IDENT'), Ref('DELIM'),
                       Rep(Not(Ref('space')))])])),
    Def('space', Orp('White')),
    # character classes:
    Def('White', Alt([chr(c) for c in range(33)])),
    Def('Upper', Alt(list(string.ascii_uppercase))),
    Def('Lower', Alt(list(string.ascii_lowercase))),
    Def('Alpha', Alt([Ref('Lower'), Ref('Upper')])),
    Def('Under', Lit('_')),
    Def('Neg', Lit('-')),
    Def('Digit', Alt([Lit(c) for c in string.digits])),
    Def('Hexit', Alt([Ref('Digit')]+[Lit(c) for c in 'abcdefABCDEF'])),
    Def('Alnum', Alt([Ref('Under'), Ref('Alpha'), Ref('Digit')])),
    # simple patterns:
    Def('IDENT', Seq([Alt([Ref('Under'),Ref('Alpha')]), Orp(Ref('Alnum'))])),
    Def('NUMBER',Seq([Opt(Ref('Neg')), Rep(Ref('Digit')),
                   Orp([Ref('Under'),
                        Ref('Digit'),Ref('Digit'),Ref('Digit')])])),
    Def('STRING', Alt([Seq([Lit(DQ), Rep(Ref('STRCHR')), Lit(DQ)])])),
    Def('STRCHR', Alt([Seq([Lit(ECHR), Alt([ Lit(ECHR), Lit(DQ) ])]),
                       Not(DQ) ])),
    Def('DELIM', Alt(list('(){}[]'))),
])
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10"><a id="7o9j7i21jqg0"></a><span class="section-number-2">10</span> Now define the bootstrap grammar to parse EBNF grammar definitions.</h2>
<div class="outline-text-2" id="text-10">
<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock16">ebnf = Gram('ebnf', [base], "ebnf meta-grammar (for parsing grammars)", [
    Def('main', Orp(Ref('rule'))),
    Def('rule', Seq([Var('name', Ref('IDENT')),
                     Lit('='), Ref('expr'), Lit('.') ])),
    Def('expr', Seq([ Ref('term'), Orp([Lit('|'), Ref('term') ]) ])),
    Def('term', Seq([ Ref('factor'), Rep(Ref('factor')) ])),
    Def('factor', Alt([Ref('IDENT'), Ref('STRING'),
                       Ref('rep'), Ref('opt'), Ref('grp')])),
    Def('rep', Seq([Lit('{'), New(Rep, Ref('expr')), Lit('}')])),  # 'x*'
    Def('opt', Seq([Lit('['), New(Opt, Ref('expr')), Lit(']')])),  # 'x?'
    Def('grp', Seq([Lit('('), New(Grp, Ref('expr')), Lit(')')])),  # '(x)'
])
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-2">
<h2 id="orgheadline11"><a id="u8s6vh00kqg0"></a><span class="section-number-2">11</span> Worlds for backtracking.</h2>
<div class="outline-text-2" id="text-11">
<p>
A world is a context for holding changes, similar to a working copy in a version control system. The idea is that any time we might need to backtrack (any time an <code>Alt</code> node is encountered), we'll fork a new world, and changes we make are done to the world object. This way, if the match ultimately fails, we can rewind the side effects.
</p>

<p>
This ability is common in prototype-based langugaes like Self and JavaScript (though it isn't necessarily commonly <i>used</i>). The name 'World' and the idea of applying it to parsing comes from Alex Warth's <a href="http://www.tinlizzie.org/ometa/">OMeta</a> dissertation.
</p>

<p>
It's easy to make a python class that works this way: we just override <code>__getattr__</code> (for the <code>x.a</code> syntax), and <code>__getitem__</code> (for the <code>x[a]</code> syntax) so that they delegate to a prototype object when there's no local value defined.
</p>

<p>
Since we do <i>not</i> override the corresponding <code>__setitem__</code> and <code>__setattr__</code> methods, any assignment made to an attribute or item of the world will affect the local object, leaving the prototype's value unchanged.
</p>

<p>
It's very much like what happens when overriding methods in a subclass, except it happens for individual objects rather than classes, and it happens dynamically at runtime.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock17">HOME = {} # arbitrary dictionary object

class World(dict):

    def __init__(self, proto=HOME):
        super(World, self).__init__()
        self.proto = proto

    def __getattr__(self, name):
        # called when attribute has no local definition.
        return getattr(self.proto, name)

    def __getitem__(self, key):
        if key in self.keys(): return super(World, self)[key]
        else: return self.proto[key]

    def changed(self, key, val):
        """Forks a new world, with one key changed."""
        res = World(self)
        res[key] = val
        return res
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-2">
<h2 id="orgheadline12"><a id="n0pcnnd1jqg0"></a><span class="section-number-2">12</span> Grammar Interpreter</h2>
<div class="outline-text-2" id="text-12">
<p>
We will assume for now that we have the entire string in memory.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock18">class Grin(Dispatcher):
    """Grammar Interpreter"""

    def __init__(self, root):
        super(Grin,self).__init__(root)
        self.init(root)

    def parse(self, src):
        self.env = World()
        self.src, self.pos, self.ch = src, 0, ''
        self.page, self.line, self.col = 0, 0, 0

    &lt;&lt;@methods&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13"><a id="bd6hv400kqg0"></a><span class="section-number-2">13</span> ebnf in ebnf</h2>
<div class="outline-text-2" id="text-13">
<p>
Here's an grammar for EBNF written in EBNF, so we can test the parser.
</p>

<p>
This text is adapted from <a href="http://www.inf.ethz.ch/personal/wirth/CompilerConstruction/index.html">Compiler Construction</a> by Niklaus Wirth (who invented EBNF, as well as Pascal, Modula, Oberon, and a variety of other languages).
</p>

<div class="org-src-container">

<pre class="src src-prolog" id="orgsrcblock19">main = { rule } .
rule = IDENT "=" expr "." .
expr = term { "|" term } .
term = factor { factor } .
factor = IDENT | STRING | "{" expr "}" | "[" expr "]" | "(" expr ")" .
</pre>
</div>

<p>
I placed that code in a block of its own so it would be syntax highlighted, but for python it should be inside a string.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock20">ebnf_src = '''\
&lt;&lt;ebnf&gt;&gt;
'''
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14"><a id="npdbb4e1jqg0"></a><span class="section-number-2">14</span> OUTPUT wejalboot.py</h2>
<div class="outline-text-2" id="text-14">
<p>
And now we can put the whole thing together:
</p>

<div class="org-src-container">

<pre class="src src-python">from collections import namedtuple
from warnings import warn
import string
def T(tag, doc, args):
    """Creates a new tuple type."""
    res = namedtuple(tag, args)
    if doc: res.__doc__+=' : '+doc
    return res

def TB(tag, doc, args=['body']): return T(tag, doc, args)
def TI(tag, doc, args=['item']): return T(tag, doc, args)
def TN(tag, doc, args=['name']): return T(tag, doc, args)
def T2(tag, doc, args=['name','body']): return T(tag, doc, args)

Gram = T('Gram', 'contains grammar rules (may inherit from `base`).',
         ['name', 'base', 'doc', 'body'])
Def = T('Def', 'define a named rule.', ['name','body'])
Ref = TN('Ref', 'refer to (invoke) a named rule')

Any = T('Any', 'match anything', [])
Not = TI('Not', 'fail if the pattern would match, but do not consume')
Skip = TI('Skip', 'match the pattern, but hide it from other rules')

Lit = TI('Lit', 'match literal item (using ==)')
Seq = TB('Seq', 'match a sequence of patterns')
Grp = TB('Grp', 'same as Seq, but renders in parentheses')
Alt = TB('Alt', 'match any of the alternatives')
Rep = TI('Rep', 'match 1 or more repetitions.')
Opt = TI('Opt', 'match 0 or 1 repetitions.')
Orp = TI('Orp', 'match 0 or more repetitions.')

Var = T2('Var', 'save matched string in a variable.')
Val = TN('Val', 'match against the saved value.')
New = T2('New', 'build a new class/tuple instance')
Arg = TB('Arg', 'pass matched data as arg to containing "New"')


def node_type(node):
    return node.__class__.__name__

class Dispatcher(object):
    """Provides a simple generic dispatch mechanism based on method names"""

    def _find_handler(self, prefix, node):
        """(prefix, namedtuple) -&gt; callable"""
        return getattr(self, '_'.join([prefix, node_type(node)]), self._unhandled)

    def _unhandled(self, node, *a, **kw):
        """Warn about unrecognized node types. (Just for development.)"""
        raise ValueError("no handler found for %s" % node_type(node))

    def dispatch(self, prefix, node, *a, **kw):
        """Find and invoke a handler for the given node."""
        h = self._find_handler(prefix, node)
        return h(node, *a, **kw)


class Cursor(object):

    def __init__(self, seq:[any]):
        self.seq = seq    # sequence (probably a string)
        self.val = None   # current value
        self.pos = -1     # current position
        self.fwd()

    def fwd(self)-&gt;any:
        """Move forward in the sequence and return the next item."""
        end = len(self.seq)
        self.pos = min(self.pos+1, end)
        self.val = None if self.pos == end else self.seq[self.pos] 
        return self


Match = namedtuple("Match", ['txt', 'pos'])
Match.__doc__ = "Match Result"

class Fail(object):
    """Value to indicate failure."""
    def __repr__(self):
        return "FAIL"
FAIL = Fail()

class M(namedtuple("M", ['val', 'cur', 'env'])):
    """Internal Match State"""

    @property
    def matched(self):
        return self.val is not FAIL


class Matcher(Dispatcher):
    """A simple matcher for regular languages."""

    def __init__(self, node):
        self.root = node

    def _match(self, node, cur, env):
        """returns a match state tuple (the `M` class)"""
        return self.dispatch('match', node, cur, env)

    def match(self, s:str):
        cur = Cursor(s)
        env = {}
        return self._match(self.root, cur, env).val


# class Matcher:

    def match_Lit(self, node, cur, env):
        return (M(Match(cur.val, cur.pos), cur.fwd(), env) if cur.val == node.item
                else M(FAIL, cur, env))

# class Matcher:

    def match_Alt(self, node, cur, env):
        for item in node.body:
            m = self._match(item, cur, env)
            if m.matched: return m
        return m # last failure


# class Matcher:

    def match_Seq(self, node):
        pass

    def match_Rep(self, node):
        pass

    def match_Opt(self, node):
        pass

    def match_Orp(self, node):
        pass

ECHR, SQ, DQ = ['\\', "'", '"']
base = Gram('ebnf', [], "rules common to all grammars", [
    Def('main', Orp('token')),
    Def('token',Seq([Skip(Orp(Ref('space'))),
                  Alt([Ref('STRING'), Ref('NUMBER'),
                       Ref('IDENT'), Ref('DELIM'),
                       Rep(Not(Ref('space')))])])),
    Def('space', Orp('White')),
    # character classes:
    Def('White', Alt([chr(c) for c in range(33)])),
    Def('Upper', Alt(list(string.ascii_uppercase))),
    Def('Lower', Alt(list(string.ascii_lowercase))),
    Def('Alpha', Alt([Ref('Lower'), Ref('Upper')])),
    Def('Under', Lit('_')),
    Def('Neg', Lit('-')),
    Def('Digit', Alt([Lit(c) for c in string.digits])),
    Def('Hexit', Alt([Ref('Digit')]+[Lit(c) for c in 'abcdefABCDEF'])),
    Def('Alnum', Alt([Ref('Under'), Ref('Alpha'), Ref('Digit')])),
    # simple patterns:
    Def('IDENT', Seq([Alt([Ref('Under'),Ref('Alpha')]), Orp(Ref('Alnum'))])),
    Def('NUMBER',Seq([Opt(Ref('Neg')), Rep(Ref('Digit')),
                   Orp([Ref('Under'),
                        Ref('Digit'),Ref('Digit'),Ref('Digit')])])),
    Def('STRING', Alt([Seq([Lit(DQ), Rep(Ref('STRCHR')), Lit(DQ)])])),
    Def('STRCHR', Alt([Seq([Lit(ECHR), Alt([ Lit(ECHR), Lit(DQ) ])]),
                       Not(DQ) ])),
    Def('DELIM', Alt(list('(){}[]'))),
])
ebnf = Gram('ebnf', [base], "ebnf meta-grammar (for parsing grammars)", [
    Def('main', Orp(Ref('rule'))),
    Def('rule', Seq([Var('name', Ref('IDENT')),
                     Lit('='), Ref('expr'), Lit('.') ])),
    Def('expr', Seq([ Ref('term'), Orp([Lit('|'), Ref('term') ]) ])),
    Def('term', Seq([ Ref('factor'), Rep(Ref('factor')) ])),
    Def('factor', Alt([Ref('IDENT'), Ref('STRING'),
                       Ref('rep'), Ref('opt'), Ref('grp')])),
    Def('rep', Seq([Lit('{'), New(Rep, Ref('expr')), Lit('}')])),  # 'x*'
    Def('opt', Seq([Lit('['), New(Opt, Ref('expr')), Lit(']')])),  # 'x?'
    Def('grp', Seq([Lit('('), New(Grp, Ref('expr')), Lit(')')])),  # '(x)'
])

HOME = {} # arbitrary dictionary object

class World(dict):

    def __init__(self, proto=HOME):
        super(World, self).__init__()
        self.proto = proto

    def __getattr__(self, name):
        # called when attribute has no local definition.
        return getattr(self.proto, name)

    def __getitem__(self, key):
        if key in self.keys(): return super(World, self)[key]
        else: return self.proto[key]

    def changed(self, key, val):
        """Forks a new world, with one key changed."""
        res = World(self)
        res[key] = val
        return res


class Grin(Dispatcher):
    """Grammar Interpreter"""

    def __init__(self, root):
        super(Grin,self).__init__(root)
        self.init(root)

    def parse(self, src):
        self.env = World()
        self.src, self.pos, self.ch = src, 0, ''
        self.page, self.line, self.col = 0, 0, 0


    # (inside  `class Grin`...)

    def match_Ref(self, node, cur, env):
        # pass in fresh World, then discard changes
        tup = self.match(self.defs[node.name], cur, World())
        if tup[0] is FAIL: return (FAIL, env)
        else: return (tup[0], tup[1], env)

    def match_Emp(self, node, cur, env):
        return (None, cur, env)

    def match_Seq(self, node, cur, env):
        for item in node.body:
            tup = self.match(item, cur, env)
            if tup[0] is FAIL: return (FAIL, tup[1])
            else: val, cur, env = tup
        return tup # last value

    def match_Orp(self, node, cur, env):
        vals = []
        while True:
            tup = self.match(node.item, cur, env)
            if tup[0] is FAIL: break
            else:
                val, cur, env = tup
                vals.append(val)
        return (vals, cur, env)

    def match_Not(self, node, cur, env):
        tup = self.match(node.item, cur, env)
        if tup[0] is FAIL: return (None, cur, tup[1])
        else: return (FAIL, tup[1])

    def match_Var(self, node, cur, env):
        tup = self.match(node.item, cur, env)
        if tup[0] is FAIL: return tup
        else: return (tup[0], cur, env.changed(node.name, tup[0]))

    def match_Act(self, node, cur, env):
        raise NotImplementedError('no semantic actions yet.')

    def match_Box(self, node, cur, env):
        raise NotImplementedError('no tree matching yet.')


    # (still inside  `class Grin`...)
    def init(self, node):
        return self.dispatch('init', node)

    def init_Gram(self, node):
        self.defs = {}
        for child in node.body: self.init(child)

    def init_Def(self, node):
        self.defs[node.name] = node

ebnf_src = '''\
main = { rule } .
rule = IDENT "=" expr "." .
expr = term { "|" term } .
term = factor { factor } .
factor = IDENT | STRING | "{" expr "}" | "[" expr "]" | "(" expr ")" .
'''
if __name__=="__main__":
    print(Grin(ebnf).parse(ebnf_src))
</pre>
</div>

<p>
If we try to run this now, here's what we'll get:
</p>

<div class="org-src-container">

<pre class="src src-org">=wejalboot.py:92:= *UserWarning: no handler for init_Gram*
  ~yield warn('no handler for tag: %s' % node.__class__.__name__)~
/None/
</pre>
</div>

<p>
So now our job is to go back and fill in a handler method for each node until it's able to walk the whole tree.
</p>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-2">
<h2 id="orgheadline15"><a id="yg99mk91oqg0"></a><span class="section-number-2">15</span> Inference Rules</h2>
<div class="outline-text-2" id="text-15">
<p>
These were translated from the sequent notation in Warth's Ometa paper.
</p>

<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock21"># (inside  `class Grin`...)

def match_Ref(self, node, cur, env):
    # pass in fresh World, then discard changes
    tup = self.match(self.defs[node.name], cur, World())
    if tup[0] is FAIL: return (FAIL, env)
    else: return (tup[0], tup[1], env)

def match_Emp(self, node, cur, env):
    return (None, cur, env)

def match_Seq(self, node, cur, env):
    for item in node.body:
        tup = self.match(item, cur, env)
        if tup[0] is FAIL: return (FAIL, tup[1])
        else: val, cur, env = tup
    return tup # last value

def match_Orp(self, node, cur, env):
    vals = []
    while True:
        tup = self.match(node.item, cur, env)
        if tup[0] is FAIL: break
        else:
            val, cur, env = tup
            vals.append(val)
    return (vals, cur, env)

def match_Not(self, node, cur, env):
    tup = self.match(node.item, cur, env)
    if tup[0] is FAIL: return (None, cur, tup[1])
    else: return (FAIL, tup[1])

def match_Var(self, node, cur, env):
    tup = self.match(node.item, cur, env)
    if tup[0] is FAIL: return tup
    else: return (tup[0], cur, env.changed(node.name, tup[0]))

def match_Act(self, node, cur, env):
    raise NotImplementedError('no semantic actions yet.')

def match_Box(self, node, cur, env):
    raise NotImplementedError('no tree matching yet.')
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-2">
<h2 id="orgheadline16"><a id="ks01bt30kqg0"></a><span class="section-number-2">16</span> Compilation step.</h2>
<div class="outline-text-2" id="text-16">
<div class="org-src-container">

<pre class="src src-python" id="orgsrcblock22"># (still inside  `class Grin`...)
def init(self, node):
    return self.dispatch('init', node)

def init_Gram(self, node):
    self.defs = {}
    for child in node.body: self.init(child)

def init_Def(self, node):
    self.defs[node.name] = node
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-2">
<h2 id="orgheadline17"><a id="hnv0l310pqg0"></a><span class="section-number-2">17</span> <span class="todo TODO">TODO</span> credits</h2>
<div class="outline-text-2" id="text-17">
<ul class="org-ul">
<li>grammar rules are adapted from Alessandro Warth's <a href="http://tinlizzie.org/ometa/">Ometa</a> system.</li>
</ul>
</div>
</div>
</div>
</body>
</html>
